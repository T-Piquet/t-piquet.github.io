var relearn_search_index = [
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Base De Connaissances",
    "uri": "/base-de-connaissances/index.html"
  },
  {
    "content": " Objectif Lorsque les données sont collectées, elles sont entreposées dans un certain format. Par la suite, ces données devront être analysées avec des outils qui ne sont pas nécessairement compatibles avec le format d’entreposage.\nIl est donc primordial d’être capable de passer d’un format à un autre.\nExtraction des données [ICI ON POURRAIT METTRE LA THÉORIE QU’ILS ONT BESOIN]\n[LES ÉTAPES À FAIRE DANS LE PROJET SERONT DANS LE .ipynb]\nEn science, l’extraction des données est la première étape … blabla\nFormat des données CSV [EXPLIQUER LE CSV]\nJSON [EXPLIQUER LE JSON]\nAUTRE FORMAT ???? [EXPLIQUER LE ????]\nExemple avec les APIs Les APIs sont une source très populaire pour fournir des données (ex: météo, jeux vidéo, etc). Les données fournies par les APIs sont plus souvent qu’autrement en format json.\nVoici des exemples d’utilisation:\n",
    "description": "",
    "tags": null,
    "title": "Projet - Partie 1",
    "uri": "/cours/projet-fil-rouge/partie-1/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Cours",
    "uri": "/cours/index.html"
  },
  {
    "content": " Objectif ….\nNettoyage des données ….\n",
    "description": "",
    "tags": null,
    "title": "Projet - Partie 2",
    "uri": "/cours/projet-fil-rouge/partie-2/index.html"
  },
  {
    "content": " Objectif …\nAffichage des données ….\n",
    "description": "",
    "tags": null,
    "title": "Projet - Partie 3",
    "uri": "/cours/projet-fil-rouge/partie-3/index.html"
  },
  {
    "content": " Objectif …\nAnalyse des données ….\n",
    "description": "",
    "tags": null,
    "title": "Projet - Partie 4",
    "uri": "/cours/projet-fil-rouge/partie-4/index.html"
  },
  {
    "content": " Cours Qu’est-ce qu’un programme ? Un programme, ou une application, ou encore un logiciel, est un outil permettant la réalisation de tâches.\nTraitement de texte Envois de messages Prévision météorologique Gestion de stock Montage vidéo Pour réaliser ces tâches, un programme va implémenter un ou plusieurs algorithmes dans un langage de programmation.\nQu’est-ce qu’un algorithme ? Un algorithme est une suite d’actions qui suivent un ordre précis. Cette suite d’actions représente les traitements sur les données. Un algorithme doit être clair et précis. Pour aider à concevoir la solution, un algorithme peut être traduit en ordinogramme. Attention Un algorithme ne s’exécute pas, il représente les étapes que le programme devra faire. C’est l’implémentation (le code) avec un langage qui s’exécute. Il peut y avoir plusieurs implémentations d’un même algorithme. Exemples d’algorithmes que vous connaissez déjà :\nUne recette de cuisine. Les instructions pour assembler un meuble. Les instructions pour préparer un café chaud avec du lait. La méthode pour calculer la somme des nombres de 1 à 100. Etc. Qu’est-ce qu’un langage de programmation ? Un langage de programmation est un ensemble de mots clés et des règles de syntaxe qui permettent d’écrire un programme exécutable par un système informatique.\nPour rappel, un système informatique ne comprend que le binaire (0 et 1), un langage de programmation est le meilleur moyen d’avoir un langage intelligible pour faire une interface entre l’homme et la machine (le binaire).\nLe rêve ultime est d’utiliser le langage naturel (le francais par exemple) pour écrire un programme. C’est ce qu’essaye d’entreprendre certaines compagnies d’intelligence artificielle. Les résultats pour le moment restent mitigés.\nEn attendant la réalisation de cette promesse, voici quelques langages courramment utilisés:\nEx: Python, C/C++, C#, java, Matlab, …. Langages de programmation les plus populaires : TIOBE Index - TIOBE Astuce Aucun langage n’est parfait pour toutes les tâches. On doit choisir le meilleur compromis pour la tâche à accomplir.\nEn général les gros logiciels professionels sont écrit avec plusieurs langages de programmation.\nCycle de développement logiciel Le cycle de développement d’un logiciel se décompose en plusieurs étapes que nous pouvons retrouver à travers ce schéma :\nGoffinet, F. (2021, 11 novembre). Concepts de développement logiciel.\nLe schéma représente un cercle fermé car un logiciel n’est jamais complètement fini. Il est en constante évolution dû à des besoins utilisateurs grandissants.\nPourquoi le python ? Ce langage est très utilisé dans la communauté scientifique, car il est facile à prendre en main et il offre une bonne compatibilité avec les autres outils scientifiques. Il est souvent défini comme une colle entre ces outils.\nIl propose aussi un grand nombre de librairies d’analyse scientifique très robustes comme : numpy, pandas, matplotlib…\nPython est un langage interprété orienté objet. Sa syntaxe simple offre une multitude de possibilité de développement. Il est possible de créer ses propres modules qui seront ensuite partagés à la communauté. Exemple : pipy.\nC’est un langage de programmation assez classique, il propose les mécanismes standards suivants :\nDonnées typées : entiers, réels, booléens, chaînes de caractères. Structures avancées de données : listes, dictionnaires, classes. Séquences d’instructions : écrire et exécuter une série de commandes sans avoir à intervenir entre les instructions. Structures algorithmiques : branchements conditionnels et boucles. Programmation structurée : utiliser les procédures et fonctions pour mieux organiser son code. Appeler plusieurs fichiers d’extension “.py” dans d’autres programmes à l’aide de la commande “import”. Il offre aussi l’avantage d’être un logiciel libre et open source.\nComment écrire un programme ? VScode Dans ce cours, nous allons utiliser un environement de développement (IDE) pour développer nos programmes d’analyse scientifiques avec Python. Il s’agit de Visual Studio Code.\nVisual Studio Code est comme un cahier de notes pour écrire du code.\nIl est gratuit et peut être utilisé avec beaucoup de langages de programmation, dont Python.\nIl a des fonctionnalités pratiques, comme :\naider à compléter le code. executer le programme en cours de développement. trouver des erreurs. mettre en forme le code, etc. On peut aussi ajouter des extensions pour avoir plus de fonctionnalités, comme intégrer des bibliothèques scientifiques, des vérificateurs de code, des testeurs, etc.\nInterface VS-code Premier exemple de programme en pyhton Exemple de programme simple dans python :\n# Exemple d'un programme simple qui effectue la somme de 2 nombres # Données en entrée x = 5 y = 7 # Traitement somme = x + y # Affichage print('La somme x + y est égale à : ', somme) Remarque du jour Astuce Un programme informatique fait ce que vous lui dites de faire, pas ce que vous voulez qu’il fasse.\nLab Exemple à télécharger\nVoyons ensemble comment exécuter ce programme.\n",
    "description": "",
    "tags": null,
    "title": "Introduction à la programmation",
    "uri": "/cours/introduction-%C3%A0-la-programmation/index.html"
  },
  {
    "content": " VScode Dans ce cours, nous allons utiliser un outil principal pour analyser des données scientifiques avec Python. Il s’agit de Visual Studio Code.\nVisual Studio Code est comme un cahier de notes pour écrire du code.\nIl est gratuit et peut être utilisé avec beaucoup de langages de programmation, dont Python.\nIl a des fonctionnalités pratique, comme :\naider à compléter le code. trouver des erreurs mettre en forme le code, etc. On peut aussi ajouter des extensions pour avoir plus de fonctionnalités, comme intégrer des bibliothèques scientifiques, des vérificateurs de code, des testeurs, etc.\nVisual Studio Code est donc un super outil pour écrire, exécuter et tester du code Python de manière efficace.\nL’interface de VS Code\nVisual Studio Code: Guide d’utilisation\nInstallation des outils Pour ceux qui ont un système d’exploitation Windows, voici deux fichiers exécutables qui installeront automatiquement VS Code, Python et toutes les librairies nécessaires :\nPremière étape Deuxième étape Pour une installation manuelle : voici les liens utiles pour installer les outils de développement (sur votre ordinateur personnel):\nTélécharger et installer Python : Python\nTélécharger et installer Visual Studio Code : Visual Studio Code - Mac, Linux, Windows\nLes extensions et bibliothèques à installer dans VS Code: Python, Run, Pandas, Numpy, Matplotlib, SciPy Tutoriel pour installer des extensions sur VS Code\nInstaller Jupyter Notebook sur Visual Studio Code (en anglais) : How to Install Jupyter Notebook in VSCode | Jupyter Notebook in Visual Studio Code (Easy)\n",
    "description": "",
    "tags": null,
    "title": "VS Code",
    "uri": "/base-de-connaissances/vs-code/index.html"
  },
  {
    "content": " Qu’est-ce que l’analyse du problème ? L’analyse du problème\nL’analyse du problème est une étape cruciale dans le processus de résolution de problèmes en informatique. Elle implique la détermination des données d’entrée, des données de sortie et la nature des traitements. Les données d’entrée\nLes données d’entrée sont les informations dont nous disposons au début. En bref, la question qui se pose est : “De quoi avons nous besoin pour obtenir le résultat recherché?” Les données en entrée peuvent provenir de diverses sources, comme des observations, des mesures, des expériences ou même des hypothèses. Par exemple, si nous étudions la croissance des plantes, les données d’entrée pourraient être la quantité de lumière, la température, le type de sol, etc. Les données de sortie\nLes données de sortie sont les résultats que nous souhaitons obtenir à partir des données d’entrée. Dans l’exemple de croissance des plantes, les données de sortie pourraient être la hauteur de la plante, le nombre de feuilles, la couleur des fleurs, etc. Les traitements\nLes traitements sont les modifications, manipulations faites sur les données d’entrée pour obtenir les données de sortie. Cela peut impliquer des calculs mathématiques, des expériences en laboratoire, des simulations informatiques, etc. Dans l’exemple de la croissance des plantes, le traitement pourrait consister à planter des graines dans différents types de sol et à mesurer leur croissance au fil du temps. En résumé, l’analyse du problème est une étape essentielle qui nous permet de comprendre clairement ce que nous savons, ce que nous voulons savoir et comment nous allons utiliser les informations disponibles pour obtenir les résultats souhaités. C’est une compétence précieuse pour tout scientifique en herbe.\nAtelier Télécharger le fichier ci-dessous et compléter les exercices : Analyse du problème\nRAPPEL : Vous devez terminer ces 5 exercices avant la fin de la séance.\n",
    "description": "",
    "tags": null,
    "title": "Analyse de problèmes",
    "uri": "/cours/analyse-de-probl%C3%A8mes/index.html"
  },
  {
    "content": "Pourquoi bien nommer les choses ? La raison est simple, on passe plus de temps a lire du code qu’a l’écrire, donc pour se simplifier la tâche de lecture du code, quel que soit le langage de programmation, il est important de bien nommer les différentes variables, méthodes etc.\nConventions de nommage en python En plus des règles liées au langage qui mèneront à un problème d’exécution (par exemple, un nom de variable ne doit pas commencer par des chiffres), il existe un nombre de convention concernant le nommage en python.\nhttps://peps.python.org/pep-0008/#naming-conventions\nType Public Packages lower_with_under Modules lower_with_under Classes CapWords Exceptions CapWords Fonctions lower_with_under() Constantes Global / Class CAPS_WITH_UNDER Variables Global / Class lower_with_under Variables d’Instance lower_with_under Nom de Methode lower_with_under() Paramètres Function / Method lower_with_under Variables locales lower_with_under La logique de nommage Bien nommer, va au dela des règles et convention du langage.\nÊtre le plus explicite possible, écrivez un nom complet. Préférez minutes à min. Si vous avez du mal à donner un nom à votre fonction, il y a probablement un problème de logique dans votre fonction. ",
    "description": "",
    "tags": null,
    "title": "Le nommage des variables",
    "uri": "/base-de-connaissances/le-nommage-en-python/index.html"
  },
  {
    "content": " La documentation du code et programme lettré La documentation du code est une pratique très importante dans le développement de logiciels. Elle permet non seulement de rendre le code compréhensible pour d’autres développeurs, mais aussi de faciliter la maintenance et l’extension du logiciel. Un programme lettré (literate programming) est une méthodologie qui combine le code et la documentation dans un même document, rendant le processus de développement plus fluide et compréhensible.\nPourquoi documenter le code ? Faciliter la compréhension : La documentation permet aux autres développeurs (et à vous-même dans le futur) de comprendre rapidement le fonctionnement du code. Améliorer la maintenabilité : Un code bien documenté est plus facile à maintenir et à modifier. Assurer la qualité : La documentation aide à vérifier que le code respecte les spécifications et les bonnes pratiques. Types de documentation Commentaires : Ce sont des commentaires insérés directement dans le code pour expliquer des lignes ou des blocs spécifiques.\n# Calculer la somme de deux nombres def addition(a, b): return a + b Docstrings : Utilisées pour documenter les modules, classes, fonctions et méthodes. Elles fournissent une description plus détaillée et structurée. C’est la méthode officielle pour documenter son code en python. Les docstrings sont utilisées par certains outils pour générer une documentation automatique sous forme de page html par exemple (pydoc)\ndef addition(a, b): \"\"\" Calcule la somme de deux nombres. Paramètres: a (int, float): Le premier nombre. b (int, float): Le deuxième nombre. Retourne: int, float: La somme des deux nombres. \"\"\" return a + b Documentation externe : Documentation séparée du code, généralement dans des fichiers Markdown ou reStructuredText, souvent utilisée pour les projets plus grands. Il peut s’agir également de document word, ou une plateforme de documentation en ligne.\nQuelques outils pour la documentation externe en Python\nSphinx : Un générateur de documentation qui crée des documents lisibles à partir de docstrings. pydoc : Génère une documentation HTML simple directement à partir des docstrings du code. MkDocs : Un générateur de documentation statique qui utilise Markdown. La programmation lettrée (Literate Programming) La programmation lettrée est une approche qui combine la documentation et le code dans un seul document. L’idée est de créer un récit compréhensible pour les humains, dans lequel le code est intégré de manière fluide.\nCette approche permet de lire et comprendre le code comme une histoire, ce qui peut être très utile pour l’apprentissage et la collaboration.\nDe nos jours, c’est la forme d’écriture la plus répandue dans la communauté scientifique aujourd’hui. Le format le plus utilisé est le notebook jupyter. Ces documents regroupent du texte en langage naturel au format markdown (md) et du code python. On peut y insérer des images pour illustrer le propos dans le texte, ou encore ces images peuvent être le résultat d’exécution du code.\nDans l’exemple ci-dessus, on voit un mélange de texte contenant des équations mathématiques, du code python et les résultats relatifs à l’exécution du code.\n",
    "description": "",
    "tags": null,
    "title": "La documentation",
    "uri": "/base-de-connaissances/la-documentation/index.html"
  },
  {
    "content": "Cours Avant d’implémenter l’algorithme dans un langage en particulier, il existe plusieurs méthodes / outils pour nous aider à valider formellement le bon fonctionnement de notre algorithme:\nle pseudo-code1 l’ordinogramme / organigramme Ordinogramme Un ordinogramme, aussi appelé organigramme de programmation est une représentation graphique de l’enchaînement des opérations, des décisions ou des fonctions à réaliser par un programme. Le programmeur devra traduire l’ordinogramme à l’aide d’un langage de programmation. L’organigramme de programmation utilise des symboles normalisés représentés ci- dessous : exemple d’ordinogramme Voici un exemple d’ordinogramme pour deviner un nombre: Lab Exercice 1 Écrire un ordinogramme qui calcule et affiche l’aire d’un rectangle à partir de la longueur et de la largeur saisies par l’utilisateur.\nExercice 2 Reprennez l’ordinogramme qui fait deviner un nombre à l’utilisateur, et modifiez le pour indiquer à l’utilisateur si le nombre saisi est plus grand ou plus petit.\nExercice 3 Ecrivez un ordinogramme qui demande à l’utilisateur de saisir un nombre puis affiche tous ses diviseurs entiers.\nVoici 2 exemples:\ndiviseurs de 30: 1, 2, 3, 5, 6, 10, 15, 30 diviseurs de 45: 1, 3, 5, 9, 15, 45 Astuce Quelle opération mathématique vous permet de savoir si un nombre est un diviseur entier ? Quand sait-on lorsqu’on a trouvé tous les diviseurs ? Pour info, cet algorithme est la première partie de l’algorithme du plus grand diviseur commun:\nDresser la liste des diviseurs de chacun des nombres. Repérer les diviseurs communs. Choisir le plus grand de ces diviseurs. Exemple de calcul de PGCD PGCD(30, 45):\nchercher les diviseurs diviseurs de 30: {1, 2, 3, 5, 6, 10, 15, 30} diviseurs de 45: {1, 3, 5, 9, 15, 45} repérer les diviseurs commun {1, 3, 5, 15} choisir le plus grand : 15 Le python est un langage tellement proche du pseudo-code, que nous le mentionnons seulement pour que vous en ayez connaissance. Nous ne l’utiliserons pas pour ce cours. ↩︎\n",
    "description": "",
    "tags": null,
    "title": "Ordinogramme",
    "uri": "/cours/ordinogramme/index.html"
  },
  {
    "content": " Affectation d’une variable En programmation, il existe plusieurs types de variables :\nles nombres entiers (int) les nombres à virgules dit les flottants (float) les chaînes de caractères (string) les booléens (bool) les listes (list) les dictionnaires (dict) Voici quelques exemples illustrés en python :\n# x est un entier x = 5 # y est un flottant y = 7.5 # salutations est une chaîne de caractères salutations = \"Bienvenue dans la faille de l'invocateur !\" # ulti_actif est un booléen qui aura pour valeur Vrai ou Faux (Faux dans notre exemple) ulti_actif = False # suite_nombre est une liste / un tableau à une dimension comportant des entiers suite_nombre = [1, 2, 3] # liste_personnage est une liste / un tableau à une dimension comportant des personnages du jeu Apex Legends liste_personnages = [\"Lifeline\", \"Fuze\", \"Bangalore\", \"Pathfinder\"] # position_lol est un dictionnaire avec comme clé la position des personnages sur la carte et en valeur leur nom. position_lol = {'Top': 'Garen', 'ADC': 'Caitlin', 'Supp': 'Leona', 'Mid': 'Lux', 'Jungle': 'Trundle' } # modele_vehicule est un dictionnaire où la clé est la marque du véhicule et les valeurs sont la liste des modèles. modele_vehicule = { 'Ford': ['Mustang', 'F150'], 'Chevrolet': ['Camaro', 'Tahoe'], 'Volkswagen':['Golf', 'Atlas']} Affichage Pour afficher le résultat de nos variables, rien de plus simple :\n# Utiliser la méthode print() pour afficher les résultats print(x) print(y) print(salutations) print(suite_nombre) print(liste_personnages) print(position_lol) print(modele_vehicule) print(ulti_actif) Lorsque vous exécuterez votre cellule, vous devriez voir le résultat suivant :\n5 7.5 Bienvenue dans la faille de l'invocateur ! [1, 2, 3] ['Lifeline', 'Fuze', 'Bangalore', 'Pathfinder'] {'Top': 'Garen', 'ADC': 'Caitlin', 'Supp': 'Leona', 'Mid': 'Lux', 'Jungle': 'Trundle'} {'Ford': ['Mustang', 'F150'], 'Chevrolet': ['Camaro', 'Tahoe'], 'Volkswagen': ['Golf', 'Atlas']} Les commentaires Les commentaires commencent par le symbole # (dièse).\nPython ignore les commentaires, c’est-à-dire qu’il ne les exécute pas.\nLes commentaires sont utilisés pour :\nExpliquer le code Rendre le code plus lisible Empêcher l’exécution lors de tests du code # Ceci est un commentaire Nomenclature des variables Les noms de variables doivent suivre certaines règles de syntaxe. Les noms de variables peuvent être composés de lettres (majuscules et/ou minuscules), de chiffres et du caractère de soulignement (_), mais ne peuvent pas commencer par un chiffre. Les noms de variables sont sensibles à la casse: ma_variable ≠ ma_Variable Exemples de noms de variables valides: ma_variable _ma_variable ma_variable1 La casse correspond à une mauvaise écriture de vos variables. Un ‘a’ minuscule ne correspond pas à un ‘A’ majuscule. a = 42 print(a) 42 Pas d’erreur ci-dessus.\nprint(A) --------------------------------------------------------------------------- NameError Traceback (most recent call last) Cell In[5], line 1 ----\u003e 1 print(A) NameError: name 'A' is not defined A est une variable non définie dans cet exemple, une erreur est logiquement affichée.\nAttention Il est important de privilégier des noms clairs pour ses variables.\nPar exemple : min = min + delta\nil est difficile de savoir rapidement si on travaille avec des minutes ou un minimum ?\nSoyez le plus explicite possible : minutes_ecoulees = minutes_ecoulees + delta_minutes\nChangement de type Pour changer le type d’une variable, nous faisons appel au transtypage.\n# x est un flottant x = 7.5 # x devient une chaîne de caractères x = str(x) # la fonction \"type()\" permet de nous retourner le type de la variable print(type(x)) Dans ce premier exemple, l’interpréteur vous montrera le résultat suivant : \u003cclass ‘str’\u003e.\n# x devient un nombre à virgule x = float(x) print(type(x)) Dans ce deuxième exemple, l’interpréteur vous montrera le résultat suivant : \u003cclass ‘float’\u003e.\nAttention Dans le cas où vous essayez de modifier une variable de type chaîne de caractères vers un entier ou un flottant, une erreur surviendra car la conversion n’est pas possible.\nExemple :\nfloat(\"Valorant\") --------------------------------------------------------------------------- ValueError Traceback (most recent call last) Cell In[3], line 1 ----\u003e 1 float(\"Valorant\") ValueError: could not convert string to float: 'Valorant' Opérations numériques Un numérique peut être un entier (int) ou un flottant (float). Les opérateurs applicables sont : Opération Symbole Exemple Résultat Addition + 7 + 5 12 Soustraction - 7 - 5 2 Multiplication * 7 * 5 35 Division Réelle / 7 / 5 1.4 Division Entière // 7 // 5 1 Modulo % 7 % 5 2 Puissance ** 7 ** 5 16807 Voici une liste non exhaustive d’exemples :\na = 7 b = 5 print(\"a =\", a, \" et b =\", b) print(\"a + b =\", a + b) print(\"a - b =\", a - b) print(\"a * b =\", a * b) print(\"a / b =\", a / b) # division print(\"a // b =\", a // b) # division entière print(\"a % b =\", a % b) # modulo print(\"a ** b =\", a ** b) # a exp b print(\"a ** -b =\", a ** -b) # a exp -b a = 7 et b = 5 a + b = 12 a - b = 2 a * b = 35 a / b = 1.4 a // b = 1 a % b = 2 a ** b = 16807 a ** -b = 5.9499018266198606e-05 Les booléens Comme vu précédemment bool correspond au type booléen, il prend deux valeurs possibles True ou False. Les opérateurs sont not (négation), and (ET logique), or (OU Logique). Voici quelques exemples:\nExpression Booléenne Valeur True or False True True and False False not True False not False True True and True True False or False False False and True False True or (False and True) True (True or False) and True True not (True and False) True Affectation multiple Voici quelques exemples d’affectations multiples :\nDans ce premier exemple, a et b se retrouvent avec la même valeur.\n# Les variables se retrouvent avec la même valeur a = b = 1 print(\"a =\", a, \" et b =\", b) a = 1 et b = 1 Dans ce deuxième exemple, 1 sera affecté à a et 2 sera affecté à b.\n# Autre méthode d'affectation multiple a, b = 1, 2 print(\"a =\", a, \" et b =\", b) a = 1 et b = 2 Opérations, expressions, enchaînements Les séquences d’instructions se font une par une comme ci-dessous :\n# Exemple d'instructions a = 1 b = 2 somme = a + b print(\"La somme de a + b est égale à :\", somme) La somme de a + b est égale à : 3 Astuce C’est la méthode la plus courante. 1 instruction = 1 ligne.\nUne variable ne se comporte pas de la même manière en fonction du côté où elle se situe par rapport à son affectation.\n# Opération particulière a = 2 print(\"1. a est égal à\", a) a = a + 1 # le résultat sera 3. print(\"2. a est maintenant égal à\", a) 1. a est égal à 2 2. a est maintenant égal à 3 Astuce Il faut lire le code de droite à gauche. Cela répond à la phrase suivante : “J’additionne 1 à ma variable a qui est déjà égale à 2. a est maintenant égal à 3.”\nOpérateurs de comparaison Les opérateurs de comparaison permettent de tester deux valeurs entre elles, le type de la variable est un booléen (True ou False). Ils seront essentiellement utilisés dans le cadre des branchements conditionnels.\nNous trouverons sous python les éléments suivants : \u003c, \u003c=, \u003e, \u003e=, !=, ==.\nExemple:\n# Comparaison dix_fois_dix = (100 == 10 *10) print(dix_fois_dix) True Dans cet exemple, nous essayons de répondre à la question : “Est-ce que 100 est égal à 10 * 10 ?”\nPremier programme Voici un exemple de programme :\n# Saisie d'une valeur valeur = int(input(\"Veuillez saisir une valeur : \")) print(\"La valeur saisie est :\", valeur) Ici l’objectif est de demander à l’utilisateur de saisir une valeur et de l’afficher. La fonction input() est utilisée pour saisir une valeur et la méthode print() permet d’afficher la valeur saisie. Il faut noter que je peux forcer l’utilisateur de saisir un type de variable. Dans cet exemple, je force l’utilisateur à saisir un entier en mettant int devant ma fonction input().\nAtelier Atelier sur les bases de python\nExemples Exemples en .ipynb\n",
    "description": "",
    "tags": null,
    "title": "Bases de Python",
    "uri": "/cours/bases-de-python/index.html"
  },
  {
    "content": " Blocs-notes Jupyter dans VS Code Jupyter (anciennement IPython Notebook) est un projet open source qui vous permet de combiner facilement du texte Markdown et du code source Python exécutable sur un canevas appelé notebook.\nVisual Studio Code prend en charge l’utilisation des blocs-notes Jupyter en mode natif et via des fichiers de code Python.\nCréer, ouvrir et enregistrer des blocs-notes Jupyter Utiliser des cellules de code Jupyter Afficher, inspecter et filtrer les variables à l’aide de l’Explorateur de variables et de la visionneuse de données Se connecter à un serveur Jupyter distant Déboguer un bloc-notes Jupyter Configuration de votre environnement Pour utiliser Python dans Jupyter Notebooks, vous devez activer un environnement Anaconda dans VS Code ou un autre environnement Python dans lequel vous avez installé le package Jupyter. Pour sélectionner un environnement, utilisez la commande Python : Sélectionner un interpréteur dans la palette de commandes (Ctrl+Maj+P).\nUne fois l’environnement approprié activé, vous pouvez créer et ouvrir un bloc-notes Jupyter, vous connecter à un serveur Jupyter distant pour exécuter des cellules de code et exporter un bloc-notes Jupyter sous forme de fichier Python.\nApprobation de l’espace de travail Lorsque vous commencez à utiliser Jupyter Notebooks, vous devez vous assurer que vous travaillez dans un espace de travail approuvé. Du code nuisible peut être incorporé dans des blocs-notes et la fonctionnalité d’approbation de l’espace de travail vous permet d’indiquer quels dossiers et leur contenu doivent autoriser ou restreindre l’exécution automatique de code.\nSi vous tentez d’ouvrir un bloc-notes lorsque VS Code se trouve dans un espace de travail non approuvé exécutant le mode restreint, vous ne pourrez pas exécuter de cellules et les sorties enrichies seront masquées.\nCréer ou ouvrir un bloc-notes Jupyter Vous pouvez créer un bloc-notes Jupyter en exécutant la commande Créer : un nouveau bloc-notes Jupyter à partir de la palette de commandes (Ctrl+Maj+P) ou en créant un fichier dans votre espace de travail..ipynb\nEnsuite, sélectionnez un noyau à l’aide du sélecteur de noyau en haut à droite.\nAprès avoir sélectionné un noyau, le sélecteur de langue situé en bas à droite de chaque cellule de code sera automatiquement mis à jour vers la langue prise en charge par le noyau.\nSi vous disposez d’un bloc-notes Jupyter, vous pouvez l’ouvrir en cliquant avec le bouton droit sur le fichier et en l’ouvrant avec VS Code, ou via l’explorateur de fichiers VS Code.\nCellules en cours d’exécution Exécuter une seule cellule de code Une fois votre code ajouté, vous pouvez exécuter une cellule à l’aide de l’icône Exécuter à gauche de la cellule et la sortie sera affichée sous la cellule de code.\nPour exécuter une cellule de code sélectionnée, vous pouvez également utiliser des raccourcis clavier en mode commande et en mode édition.\nCtrl+Entrée exécute la cellule actuellement sélectionnée. Maj+Entrée exécute la cellule actuellement sélectionnée et insère une nouvelle cellule juste en dessous (le focus se déplace vers la nouvelle cellule). Alt+Entrée exécute la cellule actuellement sélectionnée et insère une nouvelle cellule juste en dessous (le focus reste sur la cellule actuelle). Exécuter plusieurs cellules de code L’exécution de plusieurs cellules de code peut être accomplie de plusieurs façons. Vous pouvez utiliser la double flèche dans la barre d’outils principale de l’éditeur de bloc-notes pour exécuter toutes les cellules du bloc-notes ou en sélectionnant Exécuter tout, Exécuter tout au-dessus ou Exécuter tout en dessous au-dessus ou en dessous de la cellule de code actuelle.\nExécuter des cellules dans la section Pour exécuter plus facilement des cellules associées dans un bloc-notes, vous pouvez exécuter des cellules regroupées par un en-tête de section Markdown avec l’action Exécuter les cellules dans la section. Cette action est disponible dans la vue Plan du bloc-notes et pour les éléments Sticky Scroll.\nDans les éléments Sticky Scroll, cliquez avec le bouton droit sur l’en-tête de votre choix et exécutez la section via l’action dans le menu contextuel. Dans la vue Plan, sélectionnez l’icône de barre d’outils qui apparaît au survol ou à la sélection, puis exécutez une seule cellule ou une section de cellules via les actions présentées.\nVidéo: Exécuter des cellules\nEnregistrez votre bloc-notes Jupyter Vous pouvez enregistrer votre bloc-notes Jupyter à l’aide du raccourci clavier Ctrl+S ou Fichier \u003e enregistrer.\nExporter votre bloc-notes Jupyter Vous pouvez exporter un bloc-notes Jupyter sous forme de fichier Python, de fichier PDF ou de fichier HTML. Pour exporter, sélectionnez ... \u003e Exporter dans la barre d’outils principale. Une liste déroulante d’options de format de fichier vous est alors présentée.\nNote: Pour l’exportation PDF, vous devez avoir installé TeX (Installation Tex). Si vous ne le faites pas, vous serez averti que vous devez l’installer lorsque vous sélectionnerez l’option PDF. Sachez également que si vous avez une sortie SVG uniquement dans votre bloc-notes, elle ne sera pas affichée dans le PDF. Pour avoir des graphiques SVG dans un PDF, assurez-vous que votre sortie inclut un format d’image non SVG, ou bien vous pouvez d’abord exporter au format HTML, puis enregistrer au format PDF à l’aide de votre navigateur.\nUtiliser des cellules de code dans l’éditeur de bloc-notes L’éditeur de bloc-notes facilite la création, la modification et l’exécution de cellules de code dans votre bloc-notes Jupyter.\nCréer une cellule de code Par défaut, un bloc-notes vierge aura une cellule de code vide pour commencer et un bloc-notes existant en placera une en bas. Ajoutez votre code à la cellule de code vide pour commencer.\nModes de cellule de code Lorsque vous utilisez des cellules de code, une cellule peut être dans trois états : non sélectionné, mode commande et mode édition. Une barre verticale à gauche d’une cellule de code et de la bordure de l’éditeur indique l’état actuel d’une cellule. Lorsqu’aucune barre n’est visible, la cellule est désélectionnée. Lorsqu’une cellule est sélectionnée, elle peut être en mode commande ou en mode édition.\nEn mode commande, une barre verticale pleine apparaîtra à gauche de la cellule. La cellule peut être utilisée et accepte les commandes au clavier.\nEn mode édition, une barre verticale pleine est reliée par une bordure autour de l’éditeur de cellules. Le contenu de la cellule (code ou Markdown) peut être modifié.\nPour changer de mode, vous pouvez utiliser votre clavier ou votre souris. Sur votre clavier, appuyez sur la touche Entrée pour passer en mode édition ou sur la touche Échap pour passer en mode commande. Avec votre souris, cliquez sur la barre verticale à gauche de la cellule ou en dehors de la zone code/Markdown dans la cellule de code.\nAjouter des cellules de code supplémentaires Vous pouvez ajouter des cellules de code à l’aide de la barre d’outils principale, de la barre d’outils Ajouter une cellule (visible au survol) et des commandes clavier.\nPour ajouter une nouvelle cellule sous la cellule actuellement sélectionnée, utilisez l’icône plus dans la barre d’outils principale ou la barre d’outils de survol d’une cellule.\nLorsqu’une cellule de code est en mode commande, utilisez la touche A pour ajouter une cellule au-dessus et la touche B pour ajouter une cellule au-dessous de la cellule sélectionnée.\nSélectionnez une cellule de code Vous pouvez modifier une cellule de code sélectionnée à l’aide de la souris ou des touches fléchées haut/bas du clavier. Lorsqu’une cellule de code est en mode commande, vous pouvez également utiliser la touche J (bas) et la touche K (haut).\nSélectionner plusieurs cellules de code Pour sélectionner plusieurs cellules, commencez par une cellule en mode sélectionné. Un arrière-plan rempli indique les cellules sélectionnées. Pour sélectionner des cellules consécutives, maintenez la touche Maj enfoncée et cliquez sur la dernière cellule que vous souhaitez sélectionner. Pour sélectionner un groupe de cellules, maintenez la touche Ctrl enfoncée et cliquez sur les cellules que vous souhaitez ajouter à votre sélection.\nDéplacer une cellule de code Vous pouvez déplacer des cellules vers le haut ou vers le bas dans un bloc-notes par glisser-déposer. Pour les cellules de code, la zone de glisser-déposer se trouve à gauche de l’éditeur de cellule, comme indiqué ci-dessous. Pour les cellules Markdown rendues, vous pouvez cliquer n’importe où pour faire glisser et déposer des cellules.\nPour déplacer plusieurs cellules, vous pouvez utiliser les mêmes zones de glisser-déposer dans n’importe quelle cellule incluse dans la sélection.\nLe raccourci clavier Alt+Flèche déplace également une ou plusieurs cellules sélectionnées.\nSupprimer une cellule de code Pour supprimer du code, vous pouvez utiliser l’icône Supprimer dans la barre d’outils de la cellule de code. Lorsque la cellule de code sélectionnée est en mode commande, vous pouvez utiliser le raccourci clavier dd.\nAnnuler votre dernière modification Vous pouvez utiliser la touche z pour annuler votre modification précédente, par exemple, si vous avez effectué une modification accidentelle, vous pouvez l’annuler à l’état correct précédent, ou si vous avez supprimé une cellule accidentellement, vous pouvez la récupérer.\nBasculer entre le code et Markdown L’éditeur de bloc-notes vous permet de modifier facilement les cellules de code entre Markdown et le code. La sélection du sélecteur de langue en bas à droite d’une cellule vous permettra de basculer entre Markdown et, le cas échéant, toute autre langue prise en charge par le noyau sélectionné.\nVous pouvez également utiliser le clavier pour modifier le type de cellule. Lorsqu’une cellule est sélectionnée et en mode commande, la touche M bascule le type de cellule sur Markdown et la touche Y bascule le type de cellule sur code.\nUne fois Markdown défini, vous pouvez entrer du contenu au format Markdown dans la cellule de code.\nPour afficher des cellules Markdown, vous pouvez cocher la barre d’outils de la cellule ou utiliser les raccourcis clavier Ctrl+Entrée et Maj+Entrée.\nEffacer la sortie ou redémarrer/interrompre le noyau Si vous souhaitez effacer toutes les sorties de cellule de code ou redémarrer/interrompre le noyau, vous pouvez le faire à l’aide de la barre d’outils principale de l’éditeur de bloc-notes.\nActiver/désactiver les numéros de ligne Lorsque vous êtes en mode commande, vous pouvez activer ou désactiver la numérotation des lignes dans une seule cellule de code à l’aide de la touche L.\nPour basculer la numérotation des lignes pour l’ensemble du bloc-notes, utilisez Maj+L en mode commande sur n’importe quelle cellule.\nTable des matières Pour naviguer dans votre bloc-notes, ouvrez l’Explorateur de fichiers dans la barre d’activité. Ouvrez ensuite l’onglet Plan dans la barre latérale.\nNote: Par défaut, le plan n’affichera que Markdown. Pour afficher les cellules de code, activez le paramètre suivant : Contour du bloc-notes \u003e : Afficher les cellules de code.\nPrise en charge d’IntelliSense dans l’éditeur de bloc-notes Jupyter La fenêtre Python Jupyter Notebook Editor contient des informations complètes sur IntelliSense : saisie semi-automatique du code, listes de membres, informations rapides sur les méthodes et conseils de paramètre. Vous pouvez être tout aussi productif en tapant dans la fenêtre de l’éditeur de bloc-notes que dans l’éditeur de code.\nExplorateur de variables et visionneuse de données Dans un bloc-notes Python, il est possible d’afficher, d’inspecter, de trier et de filtrer les variables de votre session Jupyter actuelle. En sélectionnant l’icône Variables dans la barre d’outils principale après avoir exécuté le code et les cellules, vous verrez une liste des variables actuelles, qui seront automatiquement mises à jour au fur et à mesure que les variables sont utilisées dans le code. Le volet des variables s’ouvre en bas du bloc-notes.\nVisionneuse de données Pour plus d’informations sur vos variables, vous pouvez également double-cliquer sur une ligne ou utiliser le bouton Afficher la variable dans la visionneuse de données en regard de la variable pour obtenir une vue plus détaillée d’une variable dans la visionneuse de données.\nVous pouvez également utiliser l’expérience de visualisation des données offerte par d’autres extensions comme Data Wrangler. L’extension Data Wrangler offre une interface utilisateur riche pour afficher des informations sur vos données et vous aide à effectuer le profilage des données, les contrôles qualité, les transformations, etc.\nFiltrage des lignes Le filtrage des lignes dans la visionneuse de données peut être effectué en tapant dans la zone de texte en haut de chaque colonne. Tapez une chaîne que vous souhaitez rechercher et toute ligne contenant cette chaîne dans la colonne sera trouvée :\nSi vous voulez trouver une correspondance exacte, faites précéder votre filtre de ‘=’ :\nSauvegarde des parcelles Pour enregistrer un tracé à partir de votre bloc-notes, il suffit de survoler la sortie et de sélectionner l’icône Enregistrer en haut à droite.\nDéboguer un bloc-notes Jupyter Il existe deux façons différentes de déboguer un notebook Jupyter : un mode plus simple appelé « Run by Line » et un mode de débogage complet.\nNote: Ces deux fonctionnalités nécessitent ipykernel 6+.\nDéboguer par ligne Exécuter par ligne vous permet d’exécuter une cellule une ligne à la fois, sans être distrait par d’autres fonctionnalités de débogage VS Code. Pour commencer, sélectionnez le bouton Exécuter par ligne dans la barre d’outils de la cellule :\nUtilisez le même bouton pour avancer d’une déclaration. Vous pouvez sélectionner le bouton Arrêter la cellule pour arrêter plus tôt ou le bouton Continuer dans la barre d’outils pour continuer à s’exécuter jusqu’à la fin de la cellule.\nDéboguer la cellule Si vous souhaitez utiliser l’ensemble complet des fonctionnalités de débogage prises en charge dans VS Code, telles que les points d’arrêt et la possibilité d’effectuer un pas à pas détaillé dans d’autres cellules et modules, vous pouvez utiliser le débogueur VS Code complet.\nCommencez par définir les points d’arrêt dont vous avez besoin en cliquant dans la marge gauche d’une cellule de bloc-notes. Sélectionnez ensuite le bouton Déboguer la cellule dans le menu en regard du bouton Exécuter. Cela exécutera la cellule dans une session de débogage et s’arrêtera sur vos points d’arrêt dans tout code en cours d’exécution, même s’il se trouve dans une autre cellule ou un autre fichier..py Vous pouvez utiliser la vue Déboguer, la console Déboguer et tous les boutons de la barre d’outils Déboguer comme vous le feriez normalement dans VS Code. Rechercher dans le bloc-notes Vous pouvez effectuer une recherche dans un bloc-notes (ou des parties de celui-ci en filtrant les options de recherche) à l’aide du raccourci clavier Ctrl/Cmd + F. Cliquez sur l’option Filtrer (icône en forme d’entonnoir) pour effectuer une recherche dans :\nEntrée de cellule Markdown (Markdown Source) Sortie de cellule Markdown (Markdown rendu) Entrée de cellule de code (Source de cellule de code) Sortie de cellule de code (Sortie de cellule) Les recherches de bloc-notes sont des entrées de cellule filtrées uniquement par défaut.\nRéférence: Documentation de VS Code\n",
    "description": "",
    "tags": null,
    "title": "Jupyter",
    "uri": "/base-de-connaissances/jupyter/index.html"
  },
  {
    "content": " Pour qu’un programme soit réustilisable, il faut pouvoir intéragir avec. C’est-à-dire pouvoir modifier ses données de travail. Et pour cela, il faut que le programme donne des informations quant à son état de fonctionnement.\nEn Python, cela se fait principalement à l’aide des fonctions intégrées input() pour la lecture des données et print() pour l’affichage des résultats.\nOn peut aussi fournir des données d’entrées grâce à des fichiers de données brut sous différent format (csv, json, …), ou encore un programme peut aller lui même aller chercher des données en ligne (les dernières données météo, …).\nLecture de données au clavier La fonction input() permet de lire une ligne de texte saisie par l’utilisateur. L’argument facultatif de cette fonction est une chaîne de caractères qui sert de message d’invite.\nExemple :\nnom = input(\"Entrez votre nom : \") print(\"Bonjour, \" + nom + \"!\") Dans cet exemple, le programme demande à l’utilisateur de saisir son nom, puis affiche un message de bienvenue.\nAttention Les données lues via input() sont toujours de type chaîne de caractères (str). Si des données numériques sont attendues, il est nécessaire de faire une conversion de type (int, float, etc.).\nExemple :\nage = input(\"Entrez votre âge : \") age = int(age) # Conversion de la chaîne en entier age = age + 10 print(\"Vous aurez \" + str(age) + \" dans 10 ans.\") Affichage textuel des résultats La fonction print() est utilisée pour afficher des messages textuel à l’écran. Elle accepte plusieurs arguments, qui peuvent être de différents types, et les affiche séparément par des espaces par défaut.\nExemples :\n# Affiche Bonjour tout le monde print(\"Bonjour\", \"tout\", \"le\", \"monde\") nom = input(\"Entrer votre nom\") # Affiche Bonjour, suivi du nom saisi au clavier, puis le point d'exclamation print(\"Bonjour,\" nom, \"!\") # Affiche Vous avez 25 ans print(\"Vous avez\", age, \"ans.\")\t# Supposons que l'utilisateur a tapé 25 Formater l’affichage Python permet de formater des chaînes de caractères de différentes manières, notamment avec :\nLes f-strings (chaînes formatées). L’opérateur de formatage %. La méthode format() Aujourd’hui les méthodes 2 et 3 sont obsolettes, la méthode préconisée pour le formatage est f-string que nous verrons plus en détail ici.\n",
    "description": "",
    "tags": null,
    "title": "Intéragir avec le programme",
    "uri": "/cours/int%C3%A9ragir-avec-le-programme/index.html"
  },
  {
    "content": " Introduction au Markdown dans Jupyter Notebook Markdown est un langage de balisage léger qui vous permet de formater du texte en utilisant une syntaxe simple. Dans Jupyter Notebook, vous pouvez utiliser des cellules Markdown pour ajouter des titres, des listes, des liens, des images, et bien plus encore.\nComment créer une cellule Markdown Créer une nouvelle cellule : Cliquez sur le bouton “+” dans la barre d’outils pour ajouter une nouvelle cellule. Changer le type de cellule : Cliquez sur le menu déroulant “Code” dans la barre d’outils et sélectionnez “Markdown”. Vous pouvez également utiliser le raccourci clavier Esc puis M. Écrire du texte en Markdown : Tapez votre texte en utilisant la syntaxe Markdown. Exécuter la cellule : Appuyez sur Shift + Enter pour exécuter la cellule et afficher le texte formaté. Les bases du Markdown Titres et sous-titres:\nUtilisez les dièses # pour créer des titres. Le nombre de dièses indique le niveau du titre.\n# Titre de niveau 1 ## Titre de niveau 2 ### Titre de niveau 3 Texte en gras et en italique:\nPour mettre du texte en gras, encadrez-le avec deux astérisques ** ou deux tirets bas __.\n**texte en gras** __texte en gras__ Pour mettre du texte en italique, encadrez-le avec un astérisque * ou un tiret bas _.\n*texte en italique* _texte en italique_ Pour mettre du texte en gras et en italique, encadrez-le avec trois astérisques *** ou trois tirets bas ___.\n***Gras et italique*** ___Gras et italique___ Listes:\nListes à puces:\nUtilisez des tirets -, des astérisques * ou des signes plus + pour créer des listes à puces.\n- Élément 1 - Élément 2 - Élément 3 Listes numérotées:\nUtilisez des chiffres suivis d’un point pour créer des listes numérotées.\n1. Premier élément 2. Deuxième élément 3. Troisième élément Liens et images:\nPour insérer un lien, utilisez la syntaxe suivante :\n[Texte du lien](URL_du_lien) Pour insérer une image, utilisez la syntaxe suivante :\n![Texte alternatif](URL_de_l'image) Blocs de code:\nUtilisez des accents graves ` (backticks) pour insérer du code en ligne :\n`print(\"Hello, World!\")` Tableaux:\nCréez des tableaux en utilisant des barres verticales | et des traits d’union - pour délimiter les en-têtes et les colonnes :\n| En-tête 1 | En-tête 2 | |-----------|-----------| | Cellule 1 | Cellule 2 | | Cellule 3 | Cellule 4 | Citations:\nUtilisez le symbole \u003e pour créer des citations.\n\u003e Ceci est une citation. Formules mathématiques:\nUtilisez LaTeX pour écrire des formules mathématiques. Encadrez vos formules avec des signes dollar $.\n$E = mc^2$ Texte barré:\nUtilisez deux tildes ~~ pour barrer du texte.\n~~texte barré~~ Blocs de texte surligné:\nUtilisez trois accents graves ^^^ pour surligner des blocs de texte.\n^^^markdown Exemples pratiques Exemple de titre et de paragraphe # Mon chapitre sur le Markdown Bienvenue dans ce chapitre sur le Markdown dans Jupyter Notebook. Vous apprendrez à formater du texte facilement. Exemple de liste et de lien ## Liste des sujets abordés - Introduction au Markdown - Syntaxe de base - Les titres - Texte en gras et en italique - Les listes - Exemples pratiques - [Documentation officielle](https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Working%20With%20Markdown%20Cells.html) Exemple d’image et de bloc de code ## Exemple d'image ![Logo Jupyter](https://jupyter.org/assets/main-logo.svg) ## Exemple de code Python ```python def salut(nom): return f\"Hello, {nom}!\" print(salut(\"world\")) Vidéo YouTube Créer des cellules Markdowns dans Jupyter Notebook\n",
    "description": "",
    "tags": null,
    "title": "MarkDown",
    "uri": "/base-de-connaissances/markdown/index.html"
  },
  {
    "content": " Structures conditionnelles - if Au cours de son déroulement, un programme a besoin de prendre des décisions en fonction des données qu’il rencontre.\nComment cela se traduit ?\nLa condition est très souvent une opération de comparaison. Attention au : qui est primordial. C’est l’indentation (le décalage par rapport à la marge gauche) qui délimite le bloc d’instructions. La partie else est facultative. Exemple simple # Nous demandons à l'utilisateur de saisir un âge age = int(input(\"Saisir votre âge :\")) # Nous testons l'âge à partir de la valeur saisie par l'utilisateur # Nous pouvons noter dans cet exemple la \"condition\" qui permet de définir, grâce à l'âge, si la personne est majeure ou mineure. if age \u003e= 18: print(\"Vous êtes majeur(e).\") else: print(\"Vous êtes mineur(e).\") L’ordinogramme suivant représente le code écrit ci-dessus :\nStructures conditionnelles - Succession de if avec elif Il est naturel de se retrouver à devoir prendre un décision en fonction de multiples choix. Comment cela fonctionne avec Python ?\n# Cet algorithme a pour but de permettre à un utilisateur de choisir sa position dans \"League of Legends\" print(\"1. Support\") print(\"2. Top\") print(\"3. Mid\") print(\"4. ADC\") print(\"5. Jungle\") # L'utilisateur saisir un code en fonction de sa position position = int(input(\"Choisissez votre position : \")) # Le code saisi dans la variable position est testé pour afficher la position du joueur if(position == 1): print(\"Vous êtes Support\") elif(position == 2): print(\"Vous êtes Top\") elif(position == 3): print(\"Vous êtes Mid\") elif(position == 4): print(\"Vous êtes ADC\") else: print(\"Vous êtes Jungle\") print(\"Bienvenue dans la faille de l'invocateur !\") print(\"Des sbires sont apparus.\") elif n’est déclenché que si la (les) condition(s) précédente(s) a (ont) échoué. elif est situé au même niveau que if et else. On peut en mettre autant que l’on veut. L’ordinogramme suivant représente le code écrit ci-dessus :\nExemples Exemples en .ipynb\nAtelier Atelier sur les structures conditionnelles\nAtelier additionnel Atelier additionnel sur les structures conditionnelles\n",
    "description": "",
    "tags": null,
    "title": "Structures conditionnelles",
    "uri": "/cours/structures-conditionnelles/index.html"
  },
  {
    "content": " La syntaxe et les erreurs d’exécution en Python Python est un langage de programmation réputé pour sa simplicité et sa lisibilité. Toutefois, comme tout langage de programmation, il est sujet aux erreurs de syntaxe et d’exécution.\nComprendre la syntaxe de Python et savoir comment gérer les erreurs d’exécution est essentiel pour écrire des programmes robustes et fiables. La détection et la correction des erreurs, qu’elles soient de syntaxe ou d’exécution, permettent d’améliorer la qualité du code et d’assurer son bon fonctionnement.\nComprendre comment identifier et corriger ces erreurs est essentiel pour tout développeur.\nLes erreurs que l’on rencontre en programmation sont de 2 types:\nsyntaxique: Comme dans un langage naturelle, on peut faire des fautes d’orthographe ou de grammaire. logique: La syntaxe est correcte, mais les opérations ne répondent pas au problème, ou donnent un mauvais résultat. La syntaxe en Python La syntaxe de Python est conçue pour être claire et concise.\nVoici quelques rappel des éléments clés de la syntaxe Python :\nIndentation:\nPython utilise l’indentation pour délimiter les blocs de code. Une indentation incorrecte entraînera une erreur de syntaxe.\nDéclaration des variables\nLes variables en Python sont créées en les assignant à une valeur sans avoir besoin de déclarer leur type explicitement.\nStructures de contrôle\nLes structures de contrôle, comme les boucles et les conditions, doivent être correctement indentées et formées.\nLes erreurs de syntaxe Les erreurs de syntaxe surviennent lorsque le code ne respecte pas les règles syntaxiques de Python. Ces erreurs sont détectées lors de la phase d’interprétation du code, avant l’exécution du programme.\n1. Les erreurs d’indentation Les erreurs d’indentation sont parmi les plus courantes en Python. Elles se produisent lorsque les blocs de code ne sont pas correctement alignés.\ndef ma_fonction(): print(\"Début de la fonction\") print(\"Erreur d'indentation ici\") # Erreur d'indentation 2. Parenthèses, crochets et accolades non fermés Les erreurs de parenthèses et de crochets non fermés se produisent lorsque les parenthèses, crochets ou accolades ne sont pas correctement fermés.\n# Manque une parenthèse fermante print(\"Bonjour\" # Manque un crochet fermant ma_liste = [1, 2, 3, 4 3. Syntaxe invalide D’autres erreurs de syntaxe incluent l’utilisation incorrecte des mots-clés ou des opérateurs.\n# Utilisation incorrecte du mot-clé def 123fonction(): # Les noms de fonctions ne peuvent pas commencer par un chiffre # Opérateur incorrect resultat = 5 * * 2 # Les opérateurs doivent être correctement espacés 4. Erreurs d’exécution Les erreurs d’exécution, ou exceptions, surviennent pendant l’exécution du programme. Elles sont souvent causées par des opérations illégales, telles que la division par zéro ou l’accès à un index de liste inexistant.\nLes types d’exceptions courantes ZeroDivisionError Cette erreur se produit lorsqu’une division par zéro est tentée.\na = 10 / 0 # ZeroDivisionError IndexError Cette erreur se produit lorsqu’un index inexistant est accédé dans une liste.\nma_liste = [1, 2, 3] print(ma_liste[5]) # IndexError KeyError Cette erreur se produit lorsqu’une clé inexistante est accédée dans un dictionnaire.\nmon_dict = {\"nom\": \"Alice\", \"âge\": 25} print(mon_dict[\"adresse\"]) # KeyError TypeError Cette erreur se produit lorsqu’une opération ou une fonction est appliquée à un objet de type inapproprié.\nprint(\"Bonjour\" + 5) # TypeError Gestion des exceptions Python permet de gérer les exceptions à l’aide des blocs try-except. Cela permet d’attraper les erreurs et de les traiter de manière appropriée sans interrompre l’exécution du programme.\ntry: resultat = 10 / 0 except ZeroDivisionError: print(\"Erreur : division par zéro\") Il est également possible de gérer plusieurs types d’exceptions dans un même bloc try-except.\ntry: ma_liste = [1, 2, 3] print(ma_liste[5]) except IndexError: print(\"Erreur : index de liste incorrect\") except ZeroDivisionError: print(\"Erreur : division par zéro\") Messages d’erreur et débogage Les messages d’erreur en Python sont généralement explicites et indiquent la nature de l’erreur ainsi que la ligne du code où elle s’est produite. Analyser ces messages est crucial pour identifier et corriger les erreurs.\nExemple de message d’erreur Traceback (most recent call last): File \"main.py\", line 2, in \u003cmodule\u003e a = 10 / 0 ZeroDivisionError: division by zero Dans cet exemple, le message d’erreur indique une ZeroDivisionError sur la ligne 2 de main.py.\nVérification du fonctionnement d’un Programme La méthode print est l’une des techniques les plus simples et les plus couramment utilisées pour déboguer un programme en Python. Bien que ce ne soit pas la méthode la plus sophistiquée ni la plus efficace pour les projets complexes, print peut être extrêmement utile pour comprendre le flux d’exécution d’un programme, inspecter les valeurs des variables et identifier les points où le programme ne fonctionne pas comme prévu.\nPrincipe de base L’idée de base de l’utilisation de print pour le débogage est d’insérer des instructions print à divers endroits du programme pour afficher les valeurs des variables et les messages d’état. Cela permet de suivre l’exécution du programme et de localiser les problèmes.\ndef addition(a, b): print(f\"Entrée dans la fonction addition avec a={a} et b={b}\") resultat = a + b print(f\"Résultat de l'addition: {resultat}\") return resultat # Exemple d'utilisation resultat = addition(3, 5) print(f\"Le résultat final est: {resultat}\") Suivi du flux d’exécution En ajoutant des instructions print à différents endroits du programme, vous pouvez suivre le flux d’exécution et voir quelles parties du code sont exécutées. Cela est particulièrement utile pour les structures de contrôle comme les boucles et les conditions.\ndef verifier_parite(nombre): print(f\"Vérification de la parité pour le nombre: {nombre}\") if nombre % 2 == 0: print(\"Le nombre est pair\") return True else: print(\"Le nombre est impair\") return False # Exemple d'utilisation for i in range(5): resultat = verifier_parite(i) print(f\"Le nombre {i} est pair: {resultat}\") Inspection des variables L’une des utilisations les plus courantes de print est d’inspecter les valeurs des variables à différents points du programme. Cela permet de vérifier que les variables contiennent les valeurs attendues.\ndef calculer_somme_liste(liste): somme = 0 for element in liste: print(f\"Ajout de {element} à la somme actuelle de {somme}\") somme += element print(f\"La somme totale est: {somme}\") return somme # Exemple d'utilisation ma_liste = [1, 2, 3, 4] resultat = calculer_somme_liste(ma_liste) print(f\"Le résultat final est: {resultat}\") Débogage des fonctions récursives Le débogage des fonctions récursives peut être particulièrement difficile. L’utilisation de print pour afficher les valeurs des arguments à chaque appel récursif peut aider à comprendre le comportement de la fonction.\ndef factorielle(n): print(f\"Calcul de factorielle({n})\") if n == 0: return 1 else: resultat = n * factorielle(n - 1) print(f\"Résultat intermédiaire pour factorielle({n}): {resultat}\") return resultat # Exemple d'utilisation resultat = factorielle(5) print(f\"Le résultat final est: {resultat}\") Messages d’erreur et expressions conditionnelles Inclure des messages d’erreur conditionnels peut aider à identifier pourquoi une certaine branche du code est exécutée ou pourquoi une erreur se produit.\ndef division(a, b): if b == 0: print(\"Erreur: Tentative de division par zéro\") return None else: resultat = a / b print(f\"Résultat de la division: {resultat}\") return resultat # Exemple d'utilisation resultat = division(10, 0) if resultat is not None: print(f\"Le résultat final est: {resultat}\") Les limites de la méthode print Bien que la méthode print soit simple et efficace pour les petits projets ou pour un débogage rapide, elle présente des limites, notamment :\nVerbiage excessif : Trop d’instructions print peuvent rendre la sortie du programme difficile à lire. Performance : L’utilisation excessive de print peut ralentir l’exécution du programme. Gestion des erreurs : print ne gère pas les exceptions ou les erreurs de manière structurée. Pour ces raisons, il est souvent préférable d’utiliser des outils de débogage plus avancés, comme les tests unitaires ou les débogueurs intégrés, pour les projets plus complexes.\nAteliers Atelier sur les erreurs de syntaxe\n",
    "description": "",
    "tags": null,
    "title": "Techniques de debug",
    "uri": "/base-de-connaissances/techniques-de-debug/index.html"
  },
  {
    "content": " Cours La répétition en informatique Un des avantages en informatique est qu’il est possible de traiter un nombre conséquent d’informations en un temps réduit. Ce traitement est souvent le même, mais avec des données différentes.\nPar exemple: calculer la température moyenne de chaque semaine de l’année provenant d’un relevé quotidien de température d’une station météo. Dans ce cas, il faut répéter 52 fois une moyenne de 7 températures (du lundi au dimanche).\nUn autre exemple, serait de tester la relation entre le niveau de CO2 dans l’atmosphère et l’augmentation de la température terrestre basé sur un modèle météorologique. Dans ce cas, il faudrait exécuter un grand nombre de simulations en variant le niveau de CO2 dans l’atmosphère pour obtenir la température correspondante. On répèterait la simulation le nombre fois nécessaire pour couvrir l’amplitude choisie.\nImaginez demander à un scientifique de saisir son relevé quotidien de CO2 en prenant en compte que ce relevé ne doit pas être négatif. Donc tant que le relevé fourni est négatif, il faut redemander une nouvelle valeur à l’utilisateur.\nreleve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) if releve_co2 \u003c 0: print(\"Le niveau de CO2 ne peut être négatif.\") releve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) if releve_co2 \u003c 0: print(\"Le niveau de CO2 ne peut être négatif.\") releve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) if releve_co2 \u003c 0: print(\"Le niveau de CO2 ne peut être négatif.\") #... Sans structure de répétition, cette imbrication de if à l’infini peut être sans fin.\nBoucle while Astuce La boucle while est utile pour exécuter des itérations lorsque le nombre de répétitions nécessaires des instructions reste indéterminé. Typiquement avec des saisies utilisateurs. Il faut une condition de sortie.\nreleve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) while releve_co2 \u003c 0: print(\"Le niveau de CO2 ne peut être négatif.\") releve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) print(\"Le niveau de CO2 relevé est de : \", releve_co2) La boucle while répète les instructions tant que une certaine condition est remplie. La condition de bouclage prend exactement la même forme que les conditions avec l’instruction if. Vous pouvez donc créer des conditions complexes pour sortir de la boucle.\nPar exemple: modifier la condition pour autoriser seulement les relevés de CO2 entre 0 et 1000.\n# Saisie du relevé par l'utilisateur releve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) # Boucle sur la valeur saisie. while releve_co2 \u003c 0 or releve_co2 \u003e 1000: print(\"Un relevé de CO2 ne peut être négatif, ou supérieur à 1000\") releve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) print(\"Le niveau de CO2 relevé est de : \", releve_co2) La forme générique de l’instruction while est :\nwhile (condition): instruction1 instruction2 instruction3 ... Boucle infinie while true: instruction1 instruction2 instruction3 ... Pour sortir d’une boucle infinie, il faut utiliser le clavier et taper les touches ctrl+c.\nUtilisation d’un compteur pour arrêter une boucle Pour arrêter une boucle, il est possible d’utiliser un compteur.\nUn exemple courant: quand vous essayez de vous connecter à votre compte bancaire, il est possible qu’après de multiples tentatives erronées, votre accès au compte soit bloqué.\nDans le code, un compteur autorise l’utilisateur à saisir un certains nombres de fois son mot de passe avant de le bloquer.\nDans notre exemple, nous pourrions le représenter ainsi :\n# Initialisation d'un compteur à 3 tentatives compteur = 3 # Saisie du relevé par l'utilisateur releve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) # Boucle sur la valeur saisie et sur le nombre de tentative. while (releve_co2 \u003c 0 or releve_co2 \u003e 1000) and compteur \u003e 1: # Tant que le nombre de tentative est strictement supérieur à 1, la boucle continue print(\"Un relevé de CO2 ne peut être négatif, ou supérieur à 1000\") releve_co2 = int(input(\"Entrez le niveau de CO2 relevé: \")) compteur = compteur - 1 # A chaque boucle, le compteur est réduit de 1 tentative. # Si le compteur est égal à 1, le nombre de tentatives est trop élevé. Affichage de l'arrêt du programme. if compteur == 1: print(\"Trop de tentatives échouées. Arrêt du programme.\") else: print(\"Le niveau de CO2 relevé est de : \", releve_co2) Boucle for Astuce La boucle for se révèle utile pour exécuter des itérations dont le nombre de répétitions est connu à l’avance. Par exemple, lors du traitement de données, la quantité de données à analyser est connue à l’avance. Il faut une liste d’éléments.\nLa forme générale de la boucle for est :\nfor variable in range(n): instruction1 instruction2 instruction3 ... La boucle for est basée sur une variable d’itération. Cette variable peut être utilisée dans les instructions de la boucle. Cette variable prend les valeurs générées par l’instruction range().\nL’instruction range Que fait le code suivant ?\nfor i in range(10): if i % 2 == 0: print(i) range est une instruction qui permet de générer une suite de nombre avec lesquels nous allons faire nos répétitions.\nLa forme générale de la fonction est : range(début, fin, pas)\nSi 1 seul paramètre est spécifié, il s’agit du paramètre fin. Dans ce cas début = 0 et pas = 1.\nrange(10) =\u003e [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Si 2 paramètres sont spécifiés, il s’agit des paramètres début et fin. Dans ce cas pas = 1.\nrange(4, 10) =\u003e [4, 5, 6, 7, 8, 9] Avec les 3 paramètres spécifiés, on peut obtenir ce genre de résultat :\nrange(2, 100, 10) =\u003e [2, 12, 22, 32, 42, 52, 62, 72, 82, 92] Que fait le code suivant ?\nfor i in range(0, 10, 2): print(i) L’instruction break Lorsque un grand ensemble de données avec une boucle for est parcouru, il peut s’avérer judicieux d’interrompre les calculs dès lors qu’une valeur s’avère dénuée de sens.\nPar exemple, une donnée négative dans un relevé démographique. Dans ce cas, l’instruction break va interrompre la boucle.\nfor i in range(taille_des_donnees): if data[i] \u003c 0: print(\"Erreur: population négative\") break instruction1 instruction2 instruction3 ... Dans cet exemple, si la population est négative, l’utilisateur est averti et la boucle n’exécutera pas les instructions suivantes.\nImbrication de boucles Une instruction de bouclage reste une instruction comme les autres, on peut les enchainer les unes dans les autres.\nQue fait le code suivant ?\ncote = 3 for i in range(cote): for j in range(cote): print(\"#\", end=\"\") print(\"\") Attention En règle générale, il est rare d’avoir plus de 3 boucles imbriquées. Si c’est le cas pour résoudre un algorithme, il y a probablement un problème de logique dans la conception de votre solution.\nRemarque du jour Astuce 90% de temps d’exécution d’un programme se passe dans 10% du code.\nIl y a seulement quelques boucles responsables de la majeure partie du temps de calcul d’un programme. C’est en optimisant ces boucles que vous gagnerez en performance.\nLab Atelier sur les boucles\n",
    "description": "",
    "tags": null,
    "title": "La répétition - Les boucles",
    "uri": "/cours/la-r%C3%A9p%C3%A9tition-les-boucles/index.html"
  },
  {
    "content": " Pourquoi utiliser des listes ? Mise en situation Vous devez gérer les données des planètes des différents systèmes solaires. Chaque planète a un nom et une distance par rapport à notre soleil. Vous ne savez pas combien de planètes sont exactement présentes dans ces systèmes solaires. Vous devez afficher le nom de toutes les planètes et leur distance par rapport à notre soleil.\nSolution sans liste # Saisie de chaque variable planete_01_nom = \"Mercure\" planete_01_distance = 58 planete_02_nom = \"Vénus\" # .... planete_08_distance = 2871 # Affichage des noms et des distances un par un print(planete_01_nom, planete_01_distance) # .... print(planete_08_nom, planete_08_distance) Solution avec une liste L’utilisation des listes permettra d’exécuter cette tâche beaucoup plus facilement. Vous pourrez ajouter/modifier/enlever des planètes. Et vous pourrez ajouter plusieurs informations pour chaque planète.\n# Remplissage de la liste planetes = [] planetes.append([\"Mercure\", 58]) planetes.append([\"Vénus\", 108.2]) .... planetes.append([\"Uranus\", 2871]) # Affichage des noms et des distances dans une boucle for planete in planetes: print(planete[0], planete[1]) Qu’est-ce qu’une liste ? En Python, une liste est une collection ordonnée et modifiable d’éléments. Les listes sont utilisées pour stocker plusieurs éléments dans une seule variable et peuvent contenir des éléments de différents types, y compris des nombres, des chaînes de caractères, d’autres listes, etc. Les listes en Python sont définies en utilisant des crochets [].\nCaractéristiques d’une liste Ordonnée : Les éléments de la liste conservent un ordre défini, ce qui signifie que l’ordre dans lequel vous ajoutez les éléments est préservé. Modifiable : Une liste peut être modifiée après sa création, ce qui signifie que vous pouvez ajouter, supprimer ou changer des éléments. Taille Dynamique : Une liste en Python peut changer de taille dynamiquement. Vous pouvez ajouter ou supprimer des éléments sans avoir à spécifier la taille initiale de la liste. Hétérogène : En Python, une liste peut contenir des éléments de différents types (entiers, chaînes de caractères, listes, etc.). Bien qu’il est possible de le faire, il faut rester prudent lorsqu’on utilise des listes hétérogènes. Elles pourraient entraîner des erreurs, notamment dans les boucles. Comment utiliser une liste ? Fonctions et méthodes Fonctions len() Retourne la longueur de la liste max() Retourne la valeur maximum de la liste min() Retourne la valeur minimum de la liste Méthodes append() Ajoute un élément à la fin de la liste insert() Ajoute un élément à un endroit spécifique dans la liste remove() Supprime un élément de la valeur spécifiée pop() Supprime un élément selon sa position et retourne la valeur del() Supprime un élément selon sa position [] Permet d’accéder à un élément de la liste selon sa position extend() Ajoute tous les éléments d’une liste dans une autre liste clear() Efface tous les éléments d’une liste index() Retourne l’indice du premier élément dont la valeur est égale à celle spécifiée sort() Trie les éléments de la liste reverse() Inverse l’ordre des éléments de la liste copy() Retourne une copie superficielle de la liste Opérations simples Création d’une liste # Création d'une liste vide ma_liste = [] # ou ma_liste = list() # Liste avec des éléments ma_liste = [6, 3, 8, 9, 7, 3, 1, 2] Accès aux Éléments d’une Liste Les crochets [] sont utilisés pour accéder directement à l’élément correspondant.\n# Accès au premier élément print(ma_liste[0]) # Affiche 6 # Accès au dernier élément print(ma_liste[-1]) # Affiche 2 # Opérations sur les éléments de la liste x = ma_liste[1] + ma_liste[3] # est l'équivalent de 3 + 9, soit les éléments qui se trouve aux indices 1 et 3 print(x) # Affiche 12 Notez que les indices commencent à zéro.\nAjout d’Éléments # Liste vide ma_liste = [] # Ajoute la valeur 6 à la fin de la liste ma_liste.append(6) # Ajoute la valeur 3 à la fin de la liste ma_liste.append(3) ma_liste.append(8) ma_liste.append(9) ma_liste.append(7) ma_liste.append(3) ma_liste.append(1) ma_liste.append(2) Notez Chaque nouveau nombre est ajouté dans l’ordre. La liste restera ordonnée dans le reste du code.\nModification des Éléments # La valeur de la case à l'indice 2 est maintenant 0 ma_liste[2] = 0 # La valeur de la case à l'indice 4 est maintenant la même que celle de la case à l'indice 7 ma_liste[4] = ma_liste[7] # isch... ma_liste[0] = ma_liste[ma_liste[7]] # Décomposition du problème indice = ma_liste[7] # indice vaut 2 nouvelle_valeur = ma_liste[indice] # nouvelle_valeur vaut ma_liste[2], soit 0 ma_liste[0] = nouvelle_valeur # La case à l'indice 0 vaut maintenant 0 # Même logique... ma_liste[4] = ma_liste[ma_liste[7] + ma_liste[6]] # Décomposition du problème indice = ma_liste[7] + ma_liste[6] # indice vaut 3 nouvelle_valeur = ma_liste[indice] # nouvelle_valeur vaut ma_liste[3], soit 9 ma_liste[4] = nouvelle_valeur # La case à l'indice 4 vaut maintenant 9 Suppression d’Éléments # Supprime le dernier élément de la liste ma_liste.pop() # Supprime l'élément à l'indice 2 ma_liste.pop(2) # Supprime la première occurrence de la valeur 3 ma_liste.remove(3) Notez Lors de la suppression, les valeurs après sont décalées.\nInsertion # Insert la valeur 7 à la case 3 ma_liste.insert(3, 7) Triage # La liste est triée en ordre croissant ma_liste.sort() # La liste est triée en ordre décroissant ma_liste.sort(reverse=True) Dans une boucle Un premier exemple serait de parcourir chacun des éléments de la liste avec une boucle for:\n# Affichage de chacun des éléments de la liste for element in ma_liste: print(element) Il est aussi possible d’utiliser la fonction range() afin de parcourir la liste à l’aide des indices:\n# On additionne 1 à chaque élément de la liste for i in range(len(ma_liste)): ma_liste[i] = ma_liste[i] + 1 Enfin, la boucle while peut aussi être utile:\n# On affiche les premiers éléments de la liste. # On arrête dès que le total atteint au moins 10 ma_liste = [1, 2, 3, 4, 5, 6, 7] total = 0 i = 0 while total \u003c 10: print(ma_liste[i]) i += 1 Les listes dans les listes Une liste peut comporter tout type d’élément.\nNous pouvons donc mettre des listes dans des listes. Nous parlons alors de listes (ou tableaux) à 2 dimensions.\n# Liste contenant 3 éléments # Chaque élément est une liste contenant 2 nombres matrice = [[1, 2], [3, 4], [5, 6]] Pour parcourir toutes les listes, il suffit de mettre une boucle dans une boucle :\n# On parcourt chaque éléments de la liste principale for sous_liste in matrice: # et ensuite chaque élément de la \"sous-liste\" for element in sous_liste: print(element) Les opérations vues sur les listes en 1 dimension fonctionnent aussi pour les listes en 2D:\nprint(matrice[0]) # affiche la première liste de la matrice print(matrice[0][1]) # affiche le 2e élément de la première liste de la matrice matrice.append([7, 8]) # ajoute une nouvelle liste à la matrice Comme nous l’avons vu plus haut, la fonction range() peut aussi être utilisé pour parcourir les listes à 2 dimensions :\n# On ajoute 1 à chaque élément de la matrice for i in range(len(matrice)): for j in range(len(matrice[i])): matrice[i][j] += 1 Ateliers Prise en main des listes\nAtelier sur les listes\n",
    "description": "",
    "tags": null,
    "title": "Les Listes",
    "uri": "/cours/les-listes/index.html"
  },
  {
    "content": " Qu’est-ce qu’une Structure de Données en Python ? Une structure de données avancées en Python fait référence à des collections ou des types de données qui permettent de stocker, organiser et manipuler des données de manière efficace.\nNous avons déjà vu d’autres structures de données, soit les listes et les chaînes de caractères.\nMaintenant, nous regarderons d’autres structures de données, soit les dictionnaires, les ensembles et les tuples:\nLes dictionnaires Les dictionnaires en Python sont des collections de paires clé-valeur. Chaque élément dans un dictionnaire a une clé unique et une valeur associée. Les dictionnaires sont très utiles pour stocker des données associées.\nPar exemple, un dictionnaire pourrait être utilisé pour maintenir un inventaire d’espèces d’arbres. Les espèces seront les clés et les quantités seront les valeurs:\nEspèces Quantité Chêne 30 Pin 15 Érable 25 Bouleau 42 Sapin 25 Donc, si vous avez besoin d’une quantité, vous utiliserez le tableau ci-dessus en cherchant l’espèce qui vous intéresse.\nLes dictionnaires fonctionnent très similairement:\n# On initialise le dictionnaire avec {} ou dict() mon_dictionnaire = {} # On ajoute des éléments mon_dictionnaire[\"Chêne\"] = 30 mon_dictionnaire[\"Pin\"] = 15 mon_dictionnaire[\"Érable\"] = 25 mon_dictionnaire[\"Bouleau\"] = 42 mon_dictionnaire[\"Sapin\"] = 25 # On accède à une valeur selon la clé quantite = mon_dictionnaire[\"Pin\"] # quantite vaut 15 # On modifie une valeur mon_dictionnaire[\"Érable\"] = 5 # La valeur de \"érable\" est remplacée par 5 # On supprime une paire mon_dictionnaire.pop(\"Sapin\") # La paire ayant la clé \"Sapin\" est effacée # On vérifie si une clé est présente une_espece = \"Chêne\" if une_espece in mon_dictionnaire: print(f'L\\'espèce {une_espece} est présente.') else: print(f'L\\'espèce {une_espece} n\\'est pas présente.') Notez Les clés doivent être de type immuable, c’est-à-dire qu’elle ne peuvent pas être modifiées. Dans la majorité de cas, les clés sont des chaînes de caractères ou des nombres. Les clés doivent être uniques. Il est aussi possible de parcourir les dictionnaires, c’est-à-dire d’itérer sur chacune des paires clé-valeur:\n# Initialisation avec les données mon_dictionnaire = {'Chêne': 30,'Pin': 15,'Érable': 25,'Bouleau': 42,'Sapin': 25} # Itération sur les clés for espece in mon_dictionnaire.keys(): print(espece) # Les clés seront affichées une après l'autre print(mon_dictionnaire[espece]) # La variable \"espece\" permet d'accéder à la quantité # Itération sur les valeurs for quantite in mon_dictionnaire.values(): print(quantite) # Les quantités seront affichées une après l'autre # Itération sur les paires clé-valeur for espece, valeur in mon_dictionnaire.items(): print(espece, valeur) # Les valeurs et quantités seront affichées une après l'autre Comme pour les listes, les valeurs d’un dictionnaire peuvent être complexes. Il est possible d’utiliser des dictionnaires ou des listes comme valeurs:\n# un inventaire vide inventaire = {} # Ajout d'une paire ayant comme clé : \"site_1\", et un dictionnaire comme valeur inventaire['site_1'] = {} # Ajout d'espèce et quantité dans le dictionnaire du site_1 inventaire['site_1']['Chêne'] = 30 inventaire['site_1']['Sapin'] = 15 inventaire['site_1']['Érable'] = 25 # Ajout d'un dictionnaire (avec information) à la clé \"site_2\" inventaire['site_2'] = {'Chêne': 7,'Érable': 25,'Bouleau': 42} # Il est possible d'ajouter d'autres dictionnaires à l'intérieur inventaire['site_1']['Pin'] = {} inventaire['site_1']['Pin']['Quantité'] = 125 inventaire['site_1']['Pin']['Rangée'] = \"A\" inventaire['site_1']['Pin']['Grandeur'] = [3, 8, 12] # Affichage à l'aide de pprint from pprint import pprint pprint(inventaire) Affiche:\n{'site_1': {'Chêne': 30, 'Sapin': 15, 'Érable': 25, 'Pin': { 'Grandeur': [3, 8, 12], 'Quantité': 125, 'Rangée': 'A' }, 'site_2': {'Bouleau': 42, 'Chêne': 7, 'Érable': 25 } } Notez Les dictionnaires ne sont pas ordonnés. Par exemple, l’affichage n’est pas dans le même ordre que l’ordre d’entrée. Les Ensembles (Set) Les ensembles (ou sets) en Python sont des collections non ordonnées d’éléments uniques. Ils sont utilisés pour stocker des éléments distincts et effectuer des opérations mathématiques comme l’union, l’intersection et la différence.\n# Initialisation d'un ensemble vide mon_ensemble = set() # Ajout d'éléments mon_ensemble.add(1) # contient 1 mon_ensemble.add(2) # contient 1 et 2 mon_ensemble.add(3) # contient 1, 2 et 3 mon_ensemble.add(2) # contient 1, 2 et 3 # Initialisation d'un ensemble à partir d'une liste ma_liste = [1, 2, 3, 4, 3, 2, 1] # liste avec des doublons ensemble = set(ma_liste) # l'ensemble ne contient que [1, 2, 3, 4] # Suppression d'une valeur ensemble.remove(1) # Supprime la valeur 1 # Vérifier si l'élément est présent if 2 in ensemble: print(f'Le chiffre 2 est dans l\\'ensemble') # Itération sur les valeurs for valeur in ensemble: print(valeur) # Affiche chaque valeur de l'ensemble Les ensembles supportent plusieurs opérations mathématiques :\nensemble1 = {1, 2, 3} ensemble2 = {3, 4, 5} # Union union = ensemble1 | ensemble2 print(union) # {1, 2, 3, 4, 5} # Intersection intersection = ensemble1 \u0026 ensemble2 print(intersection) # {3} # Différence difference = ensemble1 - ensemble2 print(difference) # {1, 2} # Différence symétrique difference_sym = ensemble1 ^ ensemble2 print(difference_sym) # {1, 2, 4, 5} Les Tuples Les tuples en Python sont des séquences ordonnées et immuables de valeurs. Contrairement aux listes, les tuples ne peuvent pas être modifiés après leur création.\nPourquoi utiliser des tuples au-lieu des listes?\nContrairement aux listes, les tuples sont immuables. Dans biens des cas, cette immuabilité restreint leur utilisation et les listes sont préférées.\nPar contre, les tuples peuvent être utilisés comme clé dans les dictionnaires.\nExemple: Vous placez des objets sur un plan cartésien. Vous pourriez utiliser un tuple comme clé (x, y) et la description de l’objet comme valeur.\n# une carte vide carte = {} # ajout d'objets carte[(3, 5)] = \"Monstre\" # un Monstre à la position (3, 5) carte[(2, 8)] = \"Trésor\" # un Trésor à la position (2, 8) carte[(1, 3)] = \"Trou\" # un Trou à la position (1, 3) carte[(3, 4)] = \"Joueur\" # un Joueur à la position (3, 4) Ateliers Atelier sur les Structures de données\n",
    "description": "",
    "tags": null,
    "title": "Les Structures de Données",
    "uri": "/cours/les-structures-de-donn%C3%A9es/index.html"
  },
  {
    "content": " Qu’est-ce qu’une chaîne de caractères ? Une chaîne de caractères est simplement plusieurs caractères regroupés ensemble. Les caractères peuvent être des lettres, chiffres, symboles ou espaces. Les chaînes de caractères sont des objets que nous pouvons manipuler. Nous pouvons concaténer des chaînes, extraire ou chercher des sous-chaînes, les modifier, etc…\nEn python, les chaînes de caractères sont appelées string ou str. Elles sont entourées de guillemets simples (') ou doubles (\"):\nune_chaine = 'Bonjour' une_autre = \"Allo\" Les chaînes en Python sont immuables, ce qui signifie qu’une fois créées, elles ne peuvent pas être modifiées. Toute opération qui semble modifier une chaîne crée en réalité une nouvelle chaîne. Pour l’utilisateur (programmeur), l’immutabilité est transparente dans la plupart des cas.\nComment utiliser une chaîne de caractères ? Fonctions, Opérations et Méthodes Fonctions len() Retourne la longueur de la chaîne str() Convertit en chaîne de caractères Opérations * Multiplie une chaîne + Concatène des chaînes Méthodes [] Accède à un caractère selon sa position lower() Convertit tous les caractères de la chaîne en minuscules upper() Convertit tous les caractères de la chaîne en majuscules. strip() Supprime les espaces (ou autres caractères spécifiés) au début et à la fin de la chaîne replace() Remplace toutes les occurrences de la sous-chaîne split() Divise la chaîne en une liste de sous-chaînes join() Concatène une séquence d’éléments (comme une liste) en une seule chaîne find() Renvoie l’indice de la première occurrence de la sous-chaîne Les indices Exemples Exemples sur les chaînes de caractères\nCaractères “spéciaux” Caractère \\t Tabulation \\n Retour de ligne \\\\ Barre oblique inversée (Backslash) Le \\ permet d’échapper le caractère suivant.\nInsertion de variables Il est possible d’insérer facilement des variables dans des chaînes de caractères. Une première solution est d’utiliser la concaténation:\nvar1 = 23 var2 = 35 la_chaine = \"Le nombre \" + str(var1) + \" est plus petit que \" + str(var2) print(la_chaine) # Affiche: Le nombre 23 est plus petit que 35 Les f-strings Les f-strings sont un type de formatage des chaînes de caratères introduit assez récemment dans l’histoire de Python.\nExemple:\nnom = \"Laurence\" age = 30 print(f\"Je m'appelle {nom} et j'ai {age} ans.\") Explication:\nf-string : Le f avant les guillemets indique que la chaîne de caractères est une f-string. Cela permet d’incorporer des expressions Python directement dans la chaîne.\n{ } : Les accolades { } sont utilisées pour inclure des expressions Python à l’intérieur de la chaîne. Ces expressions sont évaluées au moment de l’exécution et leurs valeurs sont insérées dans la chaîne.\nnom est une variable contenant la chaîne “Laurence”.\nage est une variable contenant le nombre 30.\nLorsque le code est exécuté, l’expression f\"Je m'appelle {nom} et j'ai {age} ans.\" est évaluée, et les valeurs des variables nom et age sont insérées à leurs emplacements respectifs dans la chaîne. Le résultat sera :\nJe m'appelle Laurence et j'ai 30 ans. Dans une boucle Il est possible d’itérer sur chaque lettre de la chaîne:\nfor lettre in \"Bonjour\": print(lettre) Ateliers Atelier sur les chaînes de caractères\n",
    "description": "",
    "tags": null,
    "title": "Les Chaînes de caractères",
    "uri": "/cours/les-chaines-de-caract%C3%A8res/index.html"
  },
  {
    "content": " Qu’est-ce qu’une Librairie système ? En Python, les librairies systèmes fournissent des interfaces pour intéragir avec le système d’exploitation et les ressources matérielles sous-jacentes.\nUne librairie système est un ensemble de modules et de fonctions fournies par le système d’exploitation ou par des bibliothèques externes qui permettent aux programmes :\nDe communiquer avec le système d’exploitation D’accéder aux ressources matérielles De gérer des processus De manipuler des fichiers D’effectuer d’autres opérations système de bas niveau. Exemple import os # importation de la librairie os print(os.listdir('.')) # Liste les fichiers dans le répertoire courant os.mkdir(\"foo\") # Crée le répertoire foo Librairie os Ce module permet d’utiliser les fonctionnalités dépendantes du système d’exploitation telles que :\nLa gestion des fichiers et des répertoires L’exécution de commandes système Il faut d’abord importer la librairie :\nimport os Fichiers et Répertoires Qu’est-ce qu’un fichier ? Un fichier est une unité de stockage sur un ordinateur. Pensez à un fichier comme à une feuille de papier où vous pouvez écrire des informations. Les fichiers peuvent contenir différents types de données, comme du texte, des images, de la musique, des vidéos, ou des programmes.\nQu’est-ce qu’un répertoire ? Un répertoire, aussi appelé dossier, est un conteneur qui peut contenir des fichiers et d’autres répertoires. Imaginez un répertoire comme un classeur où vous pouvez organiser vos feuilles de papier (fichiers) en différentes sections (sous-dossiers).\nOrganisation des fichiers et des répertoires Les fichiers et les répertoires sont organisés dans une structure hiérarchique, souvent comparée à un arbre :\nRépertoire racine : Le répertoire principal qui contient tous les autres fichiers et répertoires. Sur Windows, il est souvent appelé C:\\. Sur macOS et Linux, il est appelé /. Sous-répertoires : Répertoires à l’intérieur d’autres répertoires. Ils permettent d’organiser les fichiers de manière logique. Par exemple, un répertoire Documents peut contenir des sous-répertoires pour des projets, des factures, etc. Chemin d’accès : La manière dont on désigne l’emplacement d’un fichier ou d’un répertoire. Par exemple, le chemin d’accès à une vidéo peut être C:\\Vidéo\\Archives\\video_01.mkv sur Windows. Dans cet exemple, Image, Musique et Vidéo sont des sous-répertoires de Racine.\nLe répertoire Vidéo contient un sous-répertoire Archives et un fichier video_03.mkv.\nLe répertoire Musique est vide.\nChemins relatif vs absolu Un chemin absolu part toujours de la racine.\nExemple:\nC:\\Vidéo\\Archives\\video_01.mkv Un chemin relatif part d’où nous sommes. Par exemple, si un programme est exécuté dans le répertoire Vidéo, son point de départ sera Vidéo. Les .. permettront de remonter au répertoire parent.\nExemples (à partir de Vidéo):\nPour accéder à video_01.mkv: .\\Archives\\video_01.mkv Pour accéder à image_01.png: ..\\Image\\image_01.png Gestion de fichiers et répertoires Lister les fichiers et les répertoires liste = os.listdir() # liste des fichiers/répertoires du répertoire courant liste = os.listdir('foo') # liste des fichiers/répertoires du sous-répertoire \"foo\" liste = os.listdir('..') # liste des fichiers/répertoires du répertoire parent liste = os.listdir('C:\\Vidéo\\Archives') # liste des fichiers/répertoires du répertoire \"Archives\" Créer un répertoire os.mkdir('nouveau_repertoire') # Crée le répertoire \"nouveau_repertoire\" dans le répertoire courant Combiner des composants de chemin chemin = os.path.join('repertoire', 'fichier.txt') # Crée le chemin à partir des chaines \"repertoire\" et \"fichier.txt\" os.path.join prend en compte le système d’exploitation pour combiner les composantes du chemin.\nSous Windows, chemin sera repertoire\\fichier.txt, tandis que sous Linux, il sera repertoire/fichier.txt.\nCe qui permettra à ce programme s’exécuter peu importe le système d’exploitation.\nVérifier si un chemin est un fichier/répertoire est_fichier = os.path.isfile('repertoire/fichier.txt') # Retourne Vrai si le fichier existe, sinon Faux est_repertoire = os.path.isdir('repertoire') # Retourne Vrai si le répertoire existe, sinon Faux La fonction os.path.exists() est plus générale et indique si le chemin existe. Cette fonction est très utilise pour éviter les erreurs:\nif os.path.exists('repertoire/fichier.txt'): # Si le fichier n'existe pas, la lecture n'aura pas lieu with open('repertoire/fichier.txt', 'r') as fichier: contenu = fichier.read() print(contenu) Supprimer un fichier/répertoire os.remove('fichier.txt') # Supprime le fichier \"fichier.txt\" os.rmdir('repertoire') # Supprime le répertoire \"repertoire\" et tout ce qui se trouve à l'intérieur Gestion de processus Exécuter une commande système La fonction os.system() permet d’exécuter des commandes système. Les commandes système sont dépendantes de votre système d’exploitation (ex: Windows vs Linux). Donc, les commandes devront être ajustées en conséquence.\nPar exemple, sous Windows, la commande dir permet d’obtenir la liste des fichiers et répertoires. Tandis que sous Linux, la commande est ls.\nos.system('ls') # Liste des fichiers et répertoire sous Linux os.system('dir') # Liste des fichiers et répertoire sous Windows Cet exemple est seulement pour illustrer la différence entre les systèmes d’exploitation. Il aurait été préférable d’utiliser la commande os.listdir() qui a la même fonctionnalité que ls ou dir, mais fonctionne sur toutes les plateformes.\nIl est possible d’exécuter d’autres programmes à l’aide la de commande os.system(). Par exemple, il est possible d’exécuter un autre script Python:\n# premierProgramme.py print('Bonjour') # deuxiemeProgramme.py os.system('python premierProgramme.py') Si on exécute deuxiemeProgramme.py, celui-ci appellera à son tour le programme premierProgramme.py qui lui affichera Bonjour.\nLibrairie sys Ce module fournit des fonctions et des variables utilisées pour manipuler différentes parties de l’environnement d’exécution Python, telles que les arguments de la ligne de commande, les variables d’environnement, le chemin de recherche de modules, etc.\nLes arguments Il est possible de lancer un programme python avec des arguments. On utilise sys.argv pour accéder à ceux-ci. sys.argv est une liste contenant les arguments sous forme de chaîne de caractères (string). La première valeur est le nom du programme.\nExemple:\n# addition.py # Programme utilisant des arguments import sys print(\"Programme:\", sys.argv[0]) # Affichera le nom du programme, soit \"addition.py\" nombre_1 = int(sys.argv[1]) # \"nombre_1\" devient la valeur numérique du 1er argument nombre_2 = int(sys.argv[2]) # \"nombre_2\" devient la valeur numérique du 2e argument reponse = nombre_1 + nombre_2 print(\"Réponse:\", reponse) addition.py\nPour lancer le programme à la ligne de commande:\n# Windows python addition.py 2 3 # Devrait donner la réponse 5 # Linux python3 addition.py 2 3 Essayez de lancer le programme sans argument.\nModifiez le programme pour éviter cette erreur.\nSortir du programme Si tout ce passe bien, les programmes terminent normalement lorsqu’il n’y a plus de code à exécuter.\nDans ce cas, le programme retournera la valeur 0.\nSi une erreur se produit en cours d’exécution et que le programme s’arrête anormalement, une valeur différente de 0 sera retournée.\nL’utilisateur du programme pourra utiliser la documentation pour connaître la signification de ce code d’erreur.\nLa fonction sys.exit() permet de sortir du programme immédiatement en retournant un code.\n# addition_2.py # Programme utilisant des arguments import sys print(\"Programme:\", sys.argv[0]) # Affichera le nom du programme, soit \"addition.py\" if len(sys.argv) != 3: print(\"Vous devez fournir 2 arguments pour l'addition\") sys.exit(1) if not sys.argv[1].isdigit() or not sys.argv[2].isdigit(): print(\"Vous devez fournir des arguments numériques pour l'addition\") sys.exit(2) nombre_1 = int(sys.argv[1]) # \"nombre_1\" devient la valeur numérique du 1er argument nombre_2 = int(sys.argv[2]) # \"nombre_2\" devient la valeur numérique du 2e argument reponse = nombre_1 + nombre_2 print(\"Réponse:\", reponse) addition_2.py\nExemple :\n# Windows python addition_2.py 2 3 # Devrait donner la réponse 5 echo %ERRORLEVEL% # Devrait donner 0 python addition_2.py 2 # Erreur echo %ERRORLEVEL% # Devrait donner 1 python addition_2.py 2 a # Erreur echo %ERRORLEVEL% # Devrait donner 2 # Linux python3 addition_2.py 2 # Erreur echo $? # Devrait donner 1 Valeur Maximale En python, la valeur maximale d’un int est de 9223372036854775807. Il est possible d’utiliser cette valeur à l’aide de sys.maxsize.\nimport sys print('Maximum :', sys.maxsize) # Affiche 9223372036854775807 Exemple d’utilisation pour trouver la valeur minimale dans une liste:\nimport sys ma_liste = [7,5,3,4,5,7,6,1,2,6] minimum_trouve = sys.maxsize # On initialise minimum_trouve avec une très grande valeur for val in ma_liste: if val \u003c minimum_trouve: minimum_trouve = val print(\"La valeur minimale est :\", minimumTrouve) Ateliers Atelier sur les librairies\nExemples Exemples en .ipynb\n",
    "description": "",
    "tags": null,
    "title": "Les Librairies systèmes",
    "uri": "/cours/les-librairies-syst%C3%A8mes/index.html"
  },
  {
    "content": " Qu’est-ce qu’un objet ? En programmation, un objet est une structure qui regroupe des données et des méthodes qui manipulent ces données. Les objets sont la pierre angulaire de la programmation orientée objet (POO), un paradigme qui organise le code en entités réutilisables et modulaires.\nConcept Définition Classe Une classe est un plan ou un modèle pour créer des objets. Objet Un objet est une instance d’une classe. Attributs Les attributs sont des variables qui appartiennent à une classe ou à un objet. Méthodes Les méthodes sont des fonctions définies à l’intérieur d’une classe. Exemple ma_liste = list() ma_liste.append(3) len(ma_liste) ma_liste est un objet créé à partir de la recette de la classe list. ma_liste contient plusieurs méthodes qui permettront de gérer/manipuler les données. Par exemple, append permet d’ajouter une donnée. len est une fonction externe à la classe qui permet d’obtenir le nombre de données que ma_liste contient.\nEncapsulation L’avantage des objets est que les méthodes et données sont encapsulés. L’utilisateur n’a pas besoin de comprendre en profondeur comment fonctionne l’objet. Il doit comprendre comment l’utiliser.\nDans l’exemple ci-haut, l’utilisateur doit comprendre que la méthode append ajoute une nouvelle valeur à la liste. Mais il n’a pas besoin de comprendre le code à l’intérieur de l’objet.\nMéthode vs Fonction Une fonction est un bloc de code qui effectue une tâche spécifique. Elle peut prendre des arguments comme entrée et peut retourner une valeur. Les fonctions sont définies indépendamment des objets et peuvent être appelées n’importe où dans le code.\nUne méthode est similaire à une fonction, mais elle est associée à un objet. Les méthodes sont définies au sein d’une classe et sont appelées sur des instances de cette classe.\nL’une des différences les plus évidentes est dans la manière dont elles sont utilisées. Les méthodes sont appelées en ajoutant un point après la variable, suivi du nom de la méthode. Les fonctions, quant à elles, prennent la variable comme argument. Exemple:\nx = [1, 2, 3] x.append(4) # méthode permettant d'ajouter une valeur len(x) # fonction qui permet d'obtenir la longueur de la liste Ateliers Atelier sur les objets\n",
    "description": "",
    "tags": null,
    "title": "Les Objets",
    "uri": "/cours/les-objets/index.html"
  },
  {
    "content": " .\nDéclaration des sous-programmes En programmation, un sous-programme est généralement appelé une fonction. Une fonction est déclarée avec le mot-clé def suivi du nom de la fonction et des parenthèses (). Les instructions à exécuter sont ensuite écrites sous cette déclaration, indentées d’une tabulation. # Déclaration d'une fonction nommée ma_fonction def ma_fonction(): print(\"Bonjour le monde!\") Appel des sous-programmes Lorsqu’on veut utiliser une fonction, on dit qu’on appelle la fonction. Pour appeler une fonction, il suffit d’écrire son nom suivi de parenthèses (). # Appel (utilisation) de la fontion ma_fonction ma_fonction() # Affiche \"Bonjour le monde!\" Passage de paramètres Les fonctions peuvent prendre des paramètres, qui sont des valeurs passées à la fonction lors de son appel. Les paramètres sont précisés entre les parenthèses d’une fonction, lors de la déclaration de la fonction. # Déclaration de la fonction saluer def saluer(nom): print(f\"Bonjour {nom}!\") # Utilisation de la fonction saluer avec comme paramètre Nathalie saluer(\"Nathalie\") # Affiche \"Bonjour Nathalie!\" Les paramètres par défaut Les paramètres par défaut dans les fonctions en Python permettent de donner une valeur par défaut à un ou plusieurs paramètres.\nCela signifie que si un argument n’est pas fourni lors de l’appel de la fonction, le paramètre prendra la valeur par défaut spécifiée.\nLes paramètres par défaut sont très utiles pour rendre les fonctions plus flexibles et faciles à utiliser, car ils permettent de ne pas spécifier certains arguments si les valeurs par défaut conviennent.\nVoici un exemple simple pour illustrer cela :\ndef salutation(nom, message=\"Bonjour\"): print(f\"{message}, {nom}!\") # Appel de la fonction avec les deux arguments salutation(\"Nathalie\", \"Salut\") # Appel de la fonction avec seulement le premier argument salutation(\"Nathalie\") Explication\nDans cet exemple, la fonction salutation prend deux paramètres : nom et message. Le paramètre message a une valeur par défaut de \"Bonjour\". Lorsque la fonction est appelée avec les deux arguments, elle affiche “Salut, Nathalie!”. Lorsque la fonction est appelée avec seulement le premier argument, elle utilise la valeur par défaut pour message et affiche “Bonjour, Nathalie!”. Retour des sous-programmes Une fonction peut renvoyer une valeur pour que cette valeur soit **utilisée dans le reste du programme.. Pour faire en sorte qu’une fonction renvoie une valeur, on utilise le mot clé return. L’instruction avec le mot clé return DOIT être la dernière de la fonction. En d’autres mots, il ne peut pas avoir d’autres lignes de code dans une fonction, APRÈS l’instruction return # Déclaration de la fonction carre def carre(nombre): return nombre ** 2 # Utilisation de la fonction pour calculer le carré de 5 et stocker le résultat dans la variable x x = carre(5) # x vaut maintenant 25 Atelier Atelier sur les fonctions\n",
    "description": "",
    "tags": null,
    "title": "Les sous-programmes",
    "uri": "/cours/les-sous-programmes/index.html"
  },
  {
    "content": " Portée des variables La portée d’une variable fait référence à l’endroit où une variable est accessible/utilisable dans le code. En Python, les variables déclarées à l’intérieur d’une fonction sont locales à cette fonction, tandis que les variables déclarées en dehors de toute fonction sont globales. Une variable locale pourra être utilisée SEULEMENT à l’intérieur de la fonction dans laquelle elle a été déclarée. Une variable globale pourra être utilisée dans tout le programme. x = 10 # Variable globale def ma_fonction(): x = 7 # Variable locale y = x + 5 # Variable locale print(\"y:\", y) # Affiche 12 ma_fonction() print(\"x:\", x) # Affiche 10 print(\"y:\", y) # Erreur! y n'est pas défini à ce niveau Dans cet exemple, y est une variable locale à ma_fonction, donc elle n’est pas accessible en dehors de cette fonction. À l’inverse, x est une variable globale, donc elle est accessible partout dans le code. Atelier Atelier sur la portée des variables\n",
    "description": "",
    "tags": null,
    "title": "La portées des variables",
    "uri": "/cours/la-port%C3%A9e-des-variables/index.html"
  },
  {
    "content": "Cours Qu’est-ce que la trace d’exécution ? La trace d’exécution est un outil, sous forme d’un tableau, qui permet de vérifier le bon fonctionnement d’un algorithme. Elle montre l’évolution des valeurs de chacune des variables tout au long du déroulement de l’algorithme (exécution pas-à-pas).\nConstruction du tableau de la trace Les colonnes du tableau correspondent aux variables déclarées dans l’algorithme. Le titre des colonnes est le nom des variables. Le titre des lignes est le numéro des lignes de l’algorithme. Dans une cellule, on inscrira la valeur de la variable correspondante seulement si elle a changé après l’exécution de l’instruction. On peut ajouter une colonne «Console» pour simuler l’affichage à la console. Vidéo explicative: Vidéo explicative sur la trace d’exécution Exemple Prenons l’exemple de cet algorithme simple en supposant que l’utilisateur saisira 5 et 10:\n1 2 3 4 5 6 7 8 9 10 11 # Exemple d'un programme simple qui effectue la somme de 2 nombres # Données en entrée print(\"Veuillez saisir deux nombres pour en faire la somme : \") nombre1 = int(input(\"Nombre 1 : \")) nombre2 = int(input(\"Nombre 2 : \")) # Traitement somme = nombre1 + nombre2 # Affichage print(\"La somme des deux nombres saisis est égale à : \", somme) # nombre1 nombre2 somme Console 1 Saisir deux nombres pour en faire la somme 2 Nombre 1 : 3 5 4 Nombre 2 : 5 10 6 15 7 La somme des deux nombres saisis est égale à : 15 Atelier Atelier Fichier excel\n",
    "description": "",
    "tags": null,
    "title": "Traces d'exécution",
    "uri": "/cours/traces-dex%C3%A9cution/index.html"
  },
  {
    "content": " .\nQu’est-ce que Pandas et pourquoi l’utiliser ? Pandas a été développé pour fournir des structures de données flexibles et intuitives, permettant de manipuler facilement des tableaux de données avec des étiquettes de variables (colonnes) et d’individus (lignes). Pandas a été créé par Wes McKinney en 2008, depuis, elle est devenue une bibliothèque de référence pour l’analyse de données en Python. Pandas se distingue par sa capacité à manipuler des données hétérogènes et étiquetées, contrairement à NumPy qui est principalement utilisé pour les tableaux numériques homogènes. De plus, Pandas intègre des fonctionnalités de visualisation via Matplotlib Les principales structures de données de Pandas sont les Series et les DataFrames. Utilisation de Pandas Pour commencer, vous devez l’importer dans votre script Python : import pandas as pd Pour vérifier que Pandas est bien installé sur votre environnement : # Version de Pandas pd.__version__ Les structures de données de base Les Series Une Series est une structure de données unidimensionnelle similaire à une liste ou un tableau. Chaque élément d’une Series a un index, ce qui permet un accès rapide et efficace aux données. L’index du premier élément est 0, le deuxième élément 1, etc. Pour une Series de taille n éléments, les index seront donc de 0 à n-1. Comment créer une Series ? Pour créer une Series, vous pouvez utiliser une liste, un dictionnaire ou même un tableau NumPy. Voici quelques exemples : # Importation de la bibliothèque Pandas import pandas as pd # Création d'une Series à partir d'une liste ma_serie = pd.Series([1, 3, 5, 7, 9]) print(ma_serie) # Création d'une Series à partir d'un dictionnaire data = {'a': 1, 'b': 2, 'c': 3} ma_serie = pd.Series(data) print(ma_serie) Comment accéder et sélectionner des données dans une Series ? Vous pouvez accéder aux éléments d’une Series en utilisant leur index : # Accès par position print(ma_serie[0]) # La donnée en première position # Accès par étiquette print(ma_serie['a']) # La donnée à l'index 'a' Les DataFrames Un DataFrame est une structure de données bidimensionnelle avec des étiquettes de lignes et de colonnes. Il est similaire à une feuille de calcul ou une table de base de données. Comment créer un DataFrame ? Vous pouvez créer un DataFrame à partir de diverses sources de données, telles que des listes de listes, des dictionnaires de listes, ou des fichiers CSV. # Création d'un DataFrame à partir d'un dictionnaire de listes data = { 'Nom': ['Julie', 'Robert', 'Charles'], 'Age': [25, 30, 35], 'Ville': ['Montréal', 'Laval', 'Rimouski'] } df = pd.DataFrame(data) print(df) Comment accéder et sélectionner des données dans un DataFrame ? Vous pouvez sélectionner des colonnes, des lignes ou des sous-ensembles de données en utilisant des méthodes comme loc et iloc.\n# Sélection d'une colonne print(df['Nom']) # Sélection de plusieurs colonnes print(df[['Nom', 'Age']]) # Sélection de lignes par étiquette print(df.loc[0]) # Sélection de lignes par position print(df.iloc[0]) Le traitement de fichiers textes Le traitement des fichiers texte, tels que les fichiers CSV, est essentiel en programmation Python, en particulier dans le domaine de la science des données. Introduction aux fichiers CSV CSV signifie Comma-Separated Values (valeurs séparées par des virgules). C’est un format de fichier simple utilisé pour stocker des données tabulaires, comme une feuille de calcul Excel ou une base de données. Lecture d’un fichier CSV La bibliothèque Pandas fournit une fonction read_csv() pour lire les fichiers CSV et les convertir en DataFrame. import pandas as pd df = pd.read_csv('fichier.csv') Explications :\npd.read_csv('fichier.csv') : Cette fonction lit le fichier CSV nommé ‘fichier.csv’. Le fichier est supposé se trouver dans le même répertoire que le script Python. La fonction retourne un DataFrame où chaque ligne du CSV devient une ligne dans le DataFrame, et les en-têtes de colonne du CSV deviennent les noms de colonne du DataFrame.\ndf = : Cette partie du code assigne le DataFrame retourné par pd.read_csv('fichier.csv') à la variable df. Après cette ligne de code, vous pouvez utiliser df pour vous référer au DataFrame.\nÉcriture dans un fichier CSV Pandas fournit également une fonction to_csv() pour écrire un DataFrame dans un fichier CSV. df.to_csv('nouveau_fichier.csv', index=False) Explications :\ndf.to_csv() : Cette fonction écrit le contenu du DataFrame df dans un fichier CSV.\n'nouveau_fichier.csv' : C’est l’argument de la fonction to_csv(), qui spécifie le nom du fichier CSV dans lequel les données seront écrites. Dans ce cas, le fichier s’appellera ’nouveau_fichier.csv’.\nindex=False : C’est un autre argument de la fonction to_csv(). Lorsqu’il est défini sur False, cela signifie que les indices des lignes du DataFrame ne seront pas écrits dans le fichier CSV. Par défaut, to_csv() écrit les indices des lignes dans le fichier CSV, donc si vous ne voulez pas cela, vous devez spécifier index=False.\nLes paramètres de la méthode read_csv Paramètre Description filepath_or_buffer Chemin du fichier ou objet de type fichier à lire. sep Caractère ou motif regex à utiliser comme délimiteur (par défaut ‘,’). delimiter Alias pour sep. header Ligne(s) à utiliser comme en-têtes de colonnes (par défaut ‘infer’). names Liste des noms de colonnes à utiliser. index_col Colonne(s) à utiliser comme index des lignes. usecols Liste des colonnes à lire. dtype Type de données pour les colonnes. engine Moteur de parsing à utiliser (‘c’ ou ‘python’). converters Dictionnaire de fonctions de conversion pour les colonnes. true_values Liste des valeurs à considérer comme True. false_values Liste des valeurs à considérer comme False. skipinitialspace Ignore les espaces après le délimiteur. skiprows Lignes à ignorer au début du fichier. skipfooter Lignes à ignorer à la fin du fichier. nrows Nombre de lignes à lire. na_values Valeurs supplémentaires à considérer comme NA/NaN. keep_default_na Garde les valeurs par défaut comme NA/NaN. na_filter Détecte les valeurs NA/NaN. verbose Affiche des informations supplémentaires lors de la lecture. skip_blank_lines Ignore les lignes vides. parse_dates Tente de convertir les colonnes en dates. infer_datetime_format Infère le format des dates. keep_date_col Garde la colonne d’origine après conversion en date. date_parser Fonction pour analyser les dates. dayfirst Considère le premier jour dans les dates. cache_dates Met en cache les dates converties. iterator Retourne un objet d’itération. chunksize Nombre de lignes par itération. compression Type de compression à utiliser. thousands Caractère utilisé pour les séparateurs de milliers. decimal Caractère utilisé pour le séparateur décimal. lineterminator Caractère utilisé pour terminer les lignes. quotechar Caractère utilisé pour les citations. quoting Contrôle la citation des champs. doublequote Contrôle le doublement des citations. escapechar Caractère utilisé pour échapper les délimiteurs. comment Caractère utilisé pour indiquer les commentaires. encoding Encodage du fichier. encoding_errors Gestion des erreurs d’encodage. dialect Dialecte à utiliser pour le parsing. on_bad_lines Action à prendre pour les lignes incorrectes. delim_whitespace Utilise les espaces comme délimiteurs. low_memory Utilise moins de mémoire lors de la lecture. memory_map Utilise la mémoire mappée pour la lecture. float_precision Précision des nombres flottants. storage_options Options de stockage supplémentaires. Les paramètres de la méthode to_csv Paramètre Description filepath_or_buffer Chemin du fichier ou objet de type fichier à lire. sep Caractère ou motif regex à utiliser comme délimiteur (par défaut ‘,’). delimiter Alias pour sep. header Ligne(s) à utiliser comme en-têtes de colonnes (par défaut ‘infer’). names Liste des noms de colonnes à utiliser. index_col Colonne(s) à utiliser comme index des lignes. usecols Liste des colonnes à lire. dtype Type de données pour les colonnes. engine Moteur de parsing à utiliser (‘c’ ou ‘python’). converters Dictionnaire de fonctions de conversion pour les colonnes. true_values Liste des valeurs à considérer comme True. false_values Liste des valeurs à considérer comme False. skipinitialspace Ignore les espaces après le délimiteur. skiprows Lignes à ignorer au début du fichier. skipfooter Lignes à ignorer à la fin du fichier. nrows Nombre de lignes à lire. na_values Valeurs supplémentaires à considérer comme NA/NaN. keep_default_na Garde les valeurs par défaut comme NA/NaN. na_filter Détecte les valeurs NA/NaN. verbose Affiche des informations supplémentaires lors de la lecture. skip_blank_lines Ignore les lignes vides. parse_dates Tente de convertir les colonnes en dates. infer_datetime_format Infère le format des dates. keep_date_col Garde la colonne d’origine après conversion en date. date_parser Fonction pour analyser les dates. dayfirst Considère le premier jour dans les dates. cache_dates Met en cache les dates converties. iterator Retourne un objet d’itération. chunksize Nombre de lignes par itération. compression Type de compression à utiliser. thousands Caractère utilisé pour les séparateurs de milliers. decimal Caractère utilisé pour le séparateur décimal. lineterminator Caractère utilisé pour terminer les lignes. quotechar Caractère utilisé pour les citations. quoting Contrôle la citation des champs. doublequote Contrôle le doublement des citations. escapechar Caractère utilisé pour échapper les délimiteurs. comment Caractère utilisé pour indiquer les commentaires. encoding Encodage du fichier. encoding_errors Gestion des erreurs d’encodage. dialect Dialecte à utiliser pour le parsing. on_bad_lines Action à prendre pour les lignes incorrectes. delim_whitespace Utilise les espaces comme délimiteurs. low_memory Utilise moins de mémoire lors de la lecture. memory_map Utilise la mémoire mappée pour la lecture. float_precision Précision des nombres flottants. storage_options Options de stockage supplémentaires. Manipulation des données Une fois que les données sont chargées dans un DataFrame, vous pouvez utiliser les nombreuses fonctionnalités de Pandas, pour manipuler les données. Par exemple, pour les nettoyer, filtrer les lignes, trier les données, grouper les données, etc. Manipulation de données La manipulation de données est une étape importante dans l’analyse de données. Elle permet de nettoyer, transformer et préparer les données pour une analyse plus approfondie. Pandas offre une multitude de méthodes pour manipuler les données de manière efficace et flexible. Exploration des données Avant de nettoyer les données, c’est important de comprendre la structure et le contenu de vos données. Pour obtenir un aperçu de vos données utilisez les méthodes suivantes: head() info() et describe(). df.head() df.head(n) # où n est le nombre de lignes à afficher df.info() df.describe() df['colonne'].describe() # où 'colonne' est le nom de la colonne à afficher Nettoyage de Données Le nettoyage des données est souvent la première étape dans la manipulation de données. Cela inclut : la gestion des valeurs manquantes, la suppression des doublons et la correction des erreurs de données. La gestion des valeurs manquantes Les valeurs manquantes peuvent être gérées de différentes manières, comme les supprimer ou les remplacer par une valeur spécifique. import pandas as pd # Création d'un DataFrame avec des valeurs manquantes data = {'Nom': ['Julie', 'Robert', 'Charles'], 'Age': [25, None, 35], 'Ville': ['Montréal', 'Laval', None]} df = pd.DataFrame(data) # Suppression des lignes avec des valeurs manquantes df_suppr = df.dropna() print(df_suppr) # Remplacement des valeurs manquantes par une valeur spécifique df_remplace = df.fillna({'Age': df['Age'].mean(), 'Ville': 'Inconnue'}) print(df_remplace) Traitement d’autres valeurs comme valeurs manquantes La méthode read_csv fourni un paramètre na_values pour pouvoir spécifier d’autres valeurs que NaN(Not a Number) à considérer comme étant manquantes, lors de la lecture d’un fichier csv.\nna_values : Ce paramètre spécifie quelles valeurs doivent être traitées comme NaN (Not a Number, utilisé pour représenter les données manquantes ou indéfinies) dans un DataFrame.\nExemple :\nSupposons que vous ayez un fichier CSV nommé ‘donnees.csv’ qui ressemble à ceci : age,poids,taille 25,70,1.75 30,\"?\",1.80 35,75,\"n.a\" Dans ce fichier, les valeurs manquantes sont représentées par “?” et “n.a”.\nVous pouvez utiliser le paramètre na_values pour indiquer à pandas de traiter ces valeurs comme NaN (Not a Number) lors de la lecture du fichier.\nVoici comment :\nimport pandas as pd df = pd.read_csv('donnees.csv', na_values=[\"?\", \"n.a\"]) Après l’exécution de ce code, le DataFrame df ressemblera à ceci : age poids taille 0 25 70.0 1.75 1 30 NaN 1.80 2 35 75.0 NaN La suppression des doublons Les doublons peuvent être supprimés pour éviter les erreurs dans l’analyse. # Suppression des doublons df_unique = df.drop_duplicates() print(df_unique) La transformation de données La transformation de données inclut : l’ajout de colonnes, la suppression de colonnes, la modification de colonnes, l’application de fonctions sur les données. L’ajout et la suppression de colonnes Vous pouvez facilement ajouter ou supprimer des colonnes dans un DataFrame. # Ajout d'une nouvelle colonne df['Pays'] = 'France' print(df) # Suppression d'une colonne df = df.drop(columns=['Ville']) print(df) Renommage de colonnes Les colonnes peuvent être renommées pour une meilleure clarté. # Renommage des colonnes df = df.rename(columns={'Nom': 'Prenom', 'Age': 'Annees'}) print(df) Application de fonctions Vous pouvez appliquer des fonctions personnalisées à des colonnes ou à des lignes entières. # Application d'une fonction à une colonne df['Age'] = df['Age'].apply(lambda x: x * 2 if pd.notnull(x) else x) print(df) # Application d'une fonction à l'ensemble du DataFrame df = df.applymap(lambda x: str(x).upper() if isinstance(x, str) else x) print(df) L’analyse de données L’analyse de données inclut le calcul de statistiques descriptives, le filtre, le tri, le groupement de données et l’affichage de graphiques avec MatplotLib. Les statistiques descriptives Pandas permet de calculer facilement des statistiques descriptives comme la moyenne, la médiane et l’écart-type. # Calcul de la moyenne et de l'écart-type print(df['Age'].mean()) print(df['Age'].std()) Filtrer les données Le filtre de données permet de visualiser une catégorie précise de données df_filtre = df[df['Age'] \u003e 18] ### Trier les données - Le tri de données permet de les visualiser dans une ordre précis ```python df_trie = df.sort_values('Age') Grouper les données Le groupement de données permet de calculer des statistiques agrégées pour des sous-ensembles de données. # Groupement par une colonne et calcul de la moyenne groupe = df.groupby('Ville')['Age'].mean() print(groupe) La manipulation de dates La manipulation des dates et des heures est une compétence essentielle en programmation, notamment pour les applications de planification, d’analyse de données et de gestion de bases de données. Python offre plusieurs modules pour travailler avec les dates et les heures, dont le plus utilisé est le module datetime.\nImportation du module Pour commencer à travailler avec les dates et les heures, vous devez importer le module datetime :\nimport datetime Création d’objets Date et Heure Date Pour créer un objet date, utilisez la classe date du module datetime :\nfrom datetime import date # Créer une date pour le 22 mai 2023 ma_date = date(2023, 5, 22) print(ma_date) # Affiche : 2023-05-22 Heure Pour créer un objet heure, utilisez la classe time :\nfrom datetime import time # Créer une heure pour 14h30m15s mon_heure = time(14, 30, 15) print(mon_heure) # Affiche : 14:30:15 Date et Heure Pour combiner une date et une heure, utilisez la classe datetime :\nfrom datetime import datetime # Créer une date et une heure pour le 22 mai 2023 à 14h30m15s ma_datetime = datetime(2023, 5, 22, 14, 30, 15) print(ma_datetime) # Affiche : 2023-05-22 14:30:15 Manipulation des Dates et Heures Extraction des composants Vous pouvez extraire les composants individuels d’un objet date ou datetime : # Extraire l'année, le mois et le jour annee = ma_date.year mois = ma_date.month jour = ma_date.day print(annee, mois, jour) # Affiche : 2023 5 22 Calculs avec les dates Le module datetime permet également de faire des calculs avec les dates en utilisant la classe timedelta : from datetime import timedelta # Ajouter 10 jours à une date nouvelle_date = ma_date + timedelta(days=10) print(nouvelle_date) # Affiche : 2023-06-01 Formatage des dates Pour afficher les dates dans différents formats, utilisez la méthode strftime : # Formatage de la date date_formatee = ma_date.strftime(\"%d/%m/%Y\") print(date_formatee) # Affiche : 22/05/2023 Visualisation des données Bien que Pandas ne soit pas spécialement conçu pour la visualisation, il offre une intégration avec la bibliothèque Matplotlib, permettant de créer rapidement des graphiques pour visualiser les données: # Tracer un histogramme de la colonne 'Taille' df['Taille'].plot.hist() NB: Pour tracer les graphiques, nous utiliserons la bibliothèque Matplotlib. Pour tout savoir sur Pandas: Site officiel Pandas.\nAtelier Atelier sur la bibliothèque Pandas\nFichier iris.csv\n",
    "description": "",
    "tags": null,
    "title": "Pandas",
    "uri": "/cours/pandas/index.html"
  },
  {
    "content": " Qu’est-ce que Matplotlib ? La visualisation de données est une compétence essentielle en sciences afin de représenter graphiquement des données complexes pour en faciliter l’analyse et l’interprétation. Matplotlib est une bibliothèque pour la visualisation de données. Elle permet de créer une variété de graphiques pour représenter les données de manière claire et informative. Utilisation de Matplotlib Pour commencer, vous devez importer dans votre script Python : import matplotlib.pyplot as plt Pour vérifier que Matplotlib est bien installé sur votre environnement : # Version de Matplotlib plt.__version__ Création de graphiques simples Graphique en Lignes import matplotlib.pyplot as plt # Les coordonnées de 5 points x = [1, 2, 3, 4, 5] y = [2, 3, 5, 7, 11] # Traçage du graphique plt.plot(x, y) # Définition des axes plt.xlabel('Axe x') plt.ylabel('Axe y') # Ajout du titre du graphique plt.title('Graphique en lignes') # Affichage du graphique plt.show() Résultat: Graphique en barres categories = ['A', 'B', 'C', 'D'] valeurs = [3, 7, 5, 4] plt.bar(categories, valeurs) plt.xlabel('Catégories') plt.ylabel('Valeurs') plt.title('Graphique en barres') plt.show() Résultat: Histogramme data = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5] plt.hist(data, bins=5, range=(1, 5), density=False, cumulative=False, color='green', edgecolor='black') plt.xlabel('Valeurs') plt.ylabel('Fréquence') plt.title('Histogramme') plt.show() Explication de la fonction hist : x : Les données à tracer sous forme de liste ou de tableau. bins : Le nombre de bacs (ou intervalles) dans lesquels les données sont regroupées. Par défaut, Matplotlib choisit automatiquement le nombre de bacs. range : Une paire de valeurs (min, max) pour définir la plage des bacs. density : Si True, l’aire sous l’histogramme sera normalisée à 1 (utile pour les distributions de probabilité). cumulative : Si True, l’histogramme sera cumulatif. color : La couleur des barres de l’histogramme. edgecolor : La couleur des bordures des barres. Résultat: Graphique en nuages de points x = [1, 2, 3, 4, 5] y = [2, 3, 5, 7, 11] sizes = [20, 50, 80, 200, 500] plt.scatter(x, y, s=sizes) plt.xlabel('Axe x') plt.ylabel('Axe y') plt.title('Graphique en nuage de points') plt.show() Résultat: Graphique en secteurs # Données labels = ['A', 'B', 'C', 'D'] sizes = [15, 30, 45, 10] explode = (0, 0.1, 0, 0) # Décale le deuxième secteur # Création du graphique en secteurs plt.pie(sizes, explode=explode, labels=labels, colors=['gold', 'yellowgreen', 'lightcoral', 'lightskyblue'], autopct='%1.1f%%', shadow=True, startangle=140) plt.axis('equal') # Assure que le graphique est circulaire plt.title('Graphique en secteurs') plt.show() Explication de la fonction pie sizes : Les tailles des secteurs, sous forme de liste ou de tableau. labels : Une séquence de chaînes de caractères fournissant les étiquettes pour chaque secteur. colors : Une séquence de couleurs pour les secteurs. autopct : Une chaîne de format ou une fonction utilisée pour étiqueter les secteurs avec leur valeur numérique. Par exemple, '%1.1f%%' affiche les pourcentages avec une décimale. pctdistance : La distance relative le long du rayon à laquelle le texte généré par autopct est dessiné. shadow : Si True, dessine une ombre sous le graphique. startangle : L’angle par lequel le début du graphique est tourné, dans le sens inverse des aiguilles d’une montre à partir de l’axe des x. radius : Le rayon du graphique. explode : Une séquence de fractions du rayon avec lesquelles décaler chaque secteur. Secteurs : Chaque secteur représente une catégorie des données. Étiquettes : Les étiquettes sont affichées à côté de chaque secteur. Pourcentages : Les pourcentages sont affichés à l’intérieur des secteurs si autopct est spécifié. Ombre : Une ombre peut être ajoutée pour un effet visuel supplémentaire. Résultat: Personnalisation et mise en forme des graphiques Couleurs et styles de lignes # Tirets verts, points marqués avec des cercles o plt.plot(x, y, color='green', linestyle='--', marker='o') plt.show() Ajout de légendes plt.plot(x, y, label='Données') plt.legend() plt.show() Annotations plt.plot(x, y) plt.annotate('Point clé', xy=(3, 5), xytext=(4, 6), arrowprops=dict(facecolor='black', shrink=0.05)) plt.show() Graphiques multiples Deux graphiques en lignes sur le même dessin x = [1, 2, 3, 4, 5] y1 = [2, 3, 5, 7, 11] y2 = [1, 4, 6, 8, 10] # Création du graphique plt.plot(x, y1, label='Série 1', color='blue', linestyle='-', marker='o') plt.plot(x, y2, label='Série 2', color='red', linestyle='--', marker='x') # Ajout des étiquettes et du titre plt.xlabel('Axe x') plt.ylabel('Axe y') plt.title('Deux graphiques en lignes') plt.legend() # Affichage du graphique plt.show() Résultat: Graphiques multiples (sous-graphes) x = [1, 2, 3, 4, 5] y = [2, 3, 5, 7, 11] sizes = [20, 50, 80, 200, 500] fig, axs = plt.subplots(2, 2) axs[0, 0].plot(x, y) axs[0, 0].set_title('Graphique 1') categories = ['A', 'B', 'C', 'D'] values = [3, 7, 5, 4] axs[0, 1].bar(categories, values) axs[0, 1].set_title('Graphique 2') data = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5] axs[1, 0].hist(data, bins=5) axs[1, 0].set_title('Graphique 3') axs[1, 1].scatter(x, y, s=sizes) axs[1, 1].set_title('Graphique 4') plt.tight_layout() plt.show() Explication\nCe code crée une figure avec quatre types de graphiques différents (ligne, barres, histogramme, nuages de points) disposés dans une grille 2x2, chacun avec son propre titre. Cela permet de visualiser plusieurs types de données sur une seule figure. Étapes du Code Création de la figure et des sous-graphes : fig, axs = plt.subplots(2, 2) plt.subplots(2, 2) crée une figure avec une grille de 2 lignes et 2 colonnes de sous-graphes. fig est la figure globale. axs est un tableau 2x2 d’axes (sous-graphes). Premier sous-graphe (Graphique 1) : axs[0, 0].plot(x, y) axs[0, 0].set_title('Graphique 1') axs[0, 0] fait référence au sous-graphe en haut à gauche. plot(x, y) trace un graphique en lignes. set_title('Graphique 1') ajoute un titre au sous-graphe. Deuxième sous-graphe (Graphique 2) : axs[0, 1].bar(categories, values) axs[0, 1].set_title('Graphique 2') axs[0, 1] fait référence au sous-graphe en haut à droite. bar(categories, values) crée un graphique en barres. set_title('Graphique 2') ajoute un titre au sous-graphe. Troisième sous-graphe (Graphique 3) : axs[1, 0].hist(data, bins=5) axs[1, 0].set_title('Graphique 3') axs[1, 0] fait référence au sous-graphe en bas à gauche. hist(data, bins=5) crée un histogramme avec 5 bacs. set_title('Graphique 3') ajoute un titre au sous-graphe. Quatrième sous-graphe (Graphique 4) : axs[1, 1].scatter(x, y, s=sizes) axs[1, 1].set_title('Graphique 4') axs[1, 1] fait référence au sous-graphe en bas à droite. scatter(x, y, s=sizes) crée un graphique en nuages de points avec des tailles de points spécifiées par sizes. set_title('Graphique 4') ajoute un titre au sous-graphe. Ajustement de la mise en page : plt.tight_layout() tight_layout() ajuste automatiquement les sous-graphes pour qu’ils ne se chevauchent pas. Affichage de la figure : plt.show() show() affiche la figure avec les quatre sous-graphes. Résultat: Liste des principales méthodes de Matplotlib Voici un tableau listant certaines des méthodes courantes de Matplotlib avec leurs descriptions :\nMéthode Description plot() Crée un graphique en ligne. scatter() Crée un graphique de dispersion. bar() Crée un graphique à barres verticales. barh() Crée un graphique à barres horizontales. hist() Crée un histogramme. pie() Crée un graphique en secteurs (camembert). boxplot() Crée un diagramme en boîte. violinplot() Crée un diagramme en violon. imshow() Affiche une image sur un graphique. contour() Crée un graphique de contours. contourf() Crée un graphique de contours remplis. pcolormesh() Crée un graphique en maillage de couleurs. errorbar() Crée un graphique en ligne avec des barres d’erreur. stackplot() Crée un graphique empilé. fill_between() Remplit l’espace entre deux courbes. subplots() Crée une figure et un ensemble de sous-graphiques. subplot() Ajoute un sous-graphe à une figure existante. legend() Ajoute une légende au graphique. xlabel() Ajoute une étiquette à l’axe des x. ylabel() Ajoute une étiquette à l’axe des y. title() Ajoute un titre au graphique. savefig() Enregistre le graphique sous forme de fichier image. show() Affiche le graphique à l’écran. Les paramètres des méthodes de traçage Voici un tableau listant les paramètres des méthodes plot, hist, scatter, pie et subplot avec leurs descriptions : Méthode Paramètre Description plot x Données pour l’axe des x. y Données pour l’axe des y. color Couleur de la ligne. linestyle Style de la ligne (par exemple, ‘-’, ‘–’, ‘-.’, ‘:’). linewidth Largeur de la ligne. marker Marqueur pour les points de données (par exemple, ‘o’, ’s’, ‘^’). label Étiquette pour la légende. alpha Transparence de la ligne (0.0 à 1.0). hist x Données pour l’histogramme. bins Nombre de bacs (bins) ou séquence définissant les bacs. range Plage des valeurs à inclure. density Si True, normalise l’histogramme. cumulative Si True, affiche un histogramme cumulatif. color Couleur des barres de l’histogramme. label Étiquette pour la légende. alpha Transparence des barres (0.0 à 1.0). scatter x Données pour l’axe des x. y Données pour l’axe des y. s Taille des marqueurs. c Couleur des marqueurs. marker Style des marqueurs (par exemple, ‘o’, ’s’, ‘^’). alpha Transparence des marqueurs (0.0 à 1.0). label Étiquette pour la légende. pie x Données pour les parts du graphique en secteurs. labels Étiquettes pour chaque part. colors Couleurs des parts. autopct Format des pourcentages affichés (par exemple, ‘%1.1f%%’). shadow Si True, ajoute une ombre. explode Décale une part du centre (par exemple, [0, 0.1, 0, 0]). startangle Angle de départ pour le premier secteur. radius Rayon du graphique en secteurs. counterclock Si True, les secteurs sont tracés dans le sens antihoraire. pctdistance Distance du centre pour les étiquettes de pourcentage. subplot nrows Nombre de lignes dans la grille de sous-graphiques. ncols Nombre de colonnes dans la grille de sous-graphiques. index Index du sous-graphe (commence à 1, va de gauche à droite, puis de haut en bas). sharex Si True, partage l’axe x avec les autres sous-graphiques. sharey Si True, partage l’axe y avec les autres sous-graphiques. figsize Taille de la figure (largeur, hauteur) en pouces. subplot_kw Dictionnaire de mots-clés pour les sous-graphiques. gridspec_kw Dictionnaire de mots-clés pour le placement des sous-graphiques. Pour tout savoir sur Matplotlib: Site officiel Matplotlib.\nAtelier Atelier sur la bibliothèque Matplotlib\nFichier ventes.csv\n",
    "description": "",
    "tags": null,
    "title": "Matplotlib",
    "uri": "/cours/matplotlib/index.html"
  },
  {
    "content": " Qu’est-ce que Numpy? Numpy (Numerical Python) est une bibliothèque pour le langage Python, ajoutant le support de grands tableaux ainsi qu’une large collection de fonctions mathématiques de haut niveau pour les opérer.\nC’est une bibliothèque essentielle pour la science des données.\nNumpy est un module Python qui s’importe comme tous les autres. De ce fait, il nous suffit d’écrire et d’éxecuter le code ci-dessous dans une cellule sur Jupyter Notebook afin d’importer cette librairie.\nimport numpy as np Pour vérifier que Numpy est bien installé à votre environnement :\n# Version de Numpy np.__version__ Vous devriez voir la version installée sous la forme de 1.XX.X. Si tel n’est pas le cas, il faudra installer Numpy comme ceci :\npip install numpy Liste non exhaustive de fonctions Numpy est doté d’une grande quantité de fonction permettant de gérer des tableaux. Il est aussi possible de faire des calculs mathématiques tel que le calcul de la moyenne, la médiane, l’écart type etc…\nFonctions array() Crée un tableau shape() Retourne la forme du tableau ndim() Retourne le nombre de dimension du tableau size() Retourne le nombre d’éléments dans le tableau zeros() Crée un tableau composé uniquement de 0 ones() Crée un tableau composé uniquement de 1 arange() Génère un tableau avec une suite de nombre en fonction du pas saisi linspace() Génère un tableau avec une suite de nombre en fonction de la quantité saisie random.randn() Génère un tableau avec des nombres basés sur la loi normale centrée réduite sum() Retourne la somme prod() Retourne le produit mean() Retourne la moyenne median() Retourne la médiane var() Retourne la variance std() Retourne l’écart type corrcoef() Retourne la corrélation entre les différentes variables sort() Tri le tableau min() Retourne la valeur minimum max() Retourne la valeur maximum argmin() Retourne l’indice de la valeur minimum argmax() Retourne l’indice de la valeur maximum Pour plus de fonctions : Site officiel Numpy.\nLes tableaux Tout comme nous avons créé des listes en Python, il est possible de créer des tableaux avec Numpy. La différence réside dans la rapidité de traitement lorsqu’il s’agit de travailler avec des données en grande quantité.\nEn effet, Numpy a été développé de sorte que les calculs soient plus rapides.\nIci, nous allons manipuler des tableaux à 1 et 2 dimensions.\nCréation d’un tableau à 1 dimension : np.array() # Tableau à une dimension tab_1d = np.array([5, 4, 2, 8]) print(tab_1d) Création d’un tableau à 2 dimensions : np.array() # Tableau à deux dimension tab_2d = np.array([[5, 4, 2, 8],[7, 10, 3, 5][8, 7, 4, 1]]) print(tab_2d) Quelques fonctions utiles pour notre tableau : np.shape(), np.size(), np.dim() Pour connaître la forme de notre tableau :\n# Retourne la forme du tableau np.shape(tab_2d) # Affiche (3, 4). Notre tableau comporte 2 lignes et 4 colonnes. Pour connaître la taille de notre tableau :\n# Retourne la forme du tableau np.size(tab_2d) # Affiche 12 comme le nombre d'éléments de notre tableau Pour connaître la dimension de notre tableau :\n# Retourne la forme du tableau np.ndim(tab_2d) # Affiche 2 comme le nombre de dimensions de notre tableau Accès indicé et découpage du tableau 1. Accès indicé Comme tous tableaux, il est possible d’accéder aux éléments à l’aide des index.\nPour notre tableau à 1 dimension, rien de plus simple : # Accès au premier élément tab_1d[0] # Affiche 5 tab_1d[2] # Affiche 2 Pour notre tableau à 2 dimensions, ils existent bien plus d’éléments à savoir : # Accès à la première ligne print(tab_2d[0]) # Affiche [5 4 2 8] De ce fait, si je souhaite accéder à la première “case” de mon tableau :\n# Accès au premier élément de notre tableau à 2 dimensions print(tab_2d[0][0]) # Affiche 5 2. Découpage du tableau Il faut savoir qu’un tableau comporte des axes (axis).\nNous avons vu que lorsque nous utilisons la fonction shape(), le premier élément correspond aux lignes et le deuxième aux colonnes du tableau. De ce fait, l’axe 0 correspond aux lignes et l’axe 1 aux colonnes de mon tableau.\nprint(tab_2d[:, 0]) # Affiche [5 7 8] soit la première colonne print(tab_2d[0, :]) # Affiche [5 4 2 8] soit la première ligne print(tab_2d[:, 0:2]) # # Affiche [[5 4][7 10][8 7]] print(tab_2d[0:2, :]) # Affiche [[5 4 2 8][7 10 3 5]] 3. Indexation booléenne L’indexation booléenne consiste à interroger notre tableau pour qu’il nous retourne “Vrai” ou “Faux” sous la forme d’un masque booléen. Par la suite, nous pourrons effectuer des modifications basées sur celui-ci.\nprint(tab_2d \u003c 7) [[ True True True False] [False False True True] [False False True True]] A partir de ce masque, je peux modifier toutes les valeurs de ce tableau qui sont inférieures à 7 et les remplacer par des valeurs égales à 3.\ntab_2d[tab_2d \u003c 7] = 3 print(tab_2d) Il est aussi possible d’effectuer des tests multiples.\ntab_2d = np.array([[5, 4, 2, 8],[7, 10, 3, 5][8, 7, 4, 1]]) tab_2d[(tab_2d \u003c 7) \u0026 (tab_2d \u003e 3)] = 3 print(tab_2d) Quelques fonctions mathématiques, de statistiques simples et diverses Numpy se dote d’un certains nombres de fonctions qui vont nous permettre d’effectuer des statistiques sur tableau.\nMathématiques 1. Somme tab_2d = np.array([[5, 4, 2, 8],[7, 10, 3, 5][8, 7, 4, 1]]) np.sum(tab_2d) # Affiche 64 Il est possible de calculer la somme en fonction d’un axe.\nnp.sum(tab_2d, axis=0) # Affiche [20, 21, 9, 14] soit la somme des colonnes np.sum(tab_2d, axis=1) # Affiche [19, 25, 20] soit la somme des lignes Cette technique pourra être utilisée pour les fonctions suivantes.\n2. Produit np.prod(tab_2d) # Affiche 75264000 3. Sinus np.sin(tab_2d) [[-0.95892427, -0.7568025 , 0.90929743, 0.98935825], [ 0.6569866 , -0.54402111, 0.14112001, -0.95892427], [ 0.98935825, 0.6569866 , -0.7568025 , 0.84147098]] 4. Exponentiel np.exp(tab_2d) [[1.48413159e+02, 5.45981500e+01, 7.38905610e+00, 2.98095799e+03], [1.09663316e+03, 2.20264658e+04, 2.00855369e+01, 1.48413159e+02], [2.98095799e+03, 1.09663316e+03, 5.45981500e+01, 2.71828183e+00]] Statistiques 1. Moyenne np.mean(tab_2d) # Affiche 5.33 2. Médiane np.median(tab_2d) # Affiche 5 3. Variance np.var(tab_2d) # Affiche 6.722222222222222 4. Ecart type np.std(tab_2d) # Affiche 2.592724864350674 5. Coefficient de corrélation np.mean(tab_2d) [[ 1. , 0.1004662 , -0.46380072], [ 0.1004662 , 1. , 0.63540406], [-0.46380072, 0.63540406, 1. ]] Diverses 1. Valeurs uniques La fonction suivante permet de retourner les valeurs uniques de notres tableaux et de compter le nombre d’occurences de ces valeurs.\nnp.unique(tab_2d, return_counts=True) array([ 1, 2, 3, 4, 5, 7, 8, 10]), array([1, 1, 1, 2, 2, 2, 2, 1], dtype=int64) 2. Importer un jeu de données Dans la majorité des cas, vous travaillerez avec des données qui vous seront fournies. Ils existent des fonctions qui vous permettent de charger ces données.\nVoici un exemple avec un fichier contenant des données météo très simplifiées réparties sur 7 jours.\ndata = np.loadtxt(\"data.csv\", delimiter=',', skiprows=1) print(data) Les arguments à passer sont :\nle nom du fichier le délimiteur (à vérifier en ouvrant votre fichier) étant donné que notre première ligne est composée de caractère, nous faisons abstraction de celle-ci. Numpy ne prend pas en charge la gestion des données numériques. [[ 1 0 10] [ 2 0 8] [ 3 5 3] [ 4 2 5] [ 5 10 1] [ 6 50 0] [ 7 0 10]] Nous retrouvons notre tableau à deux dimensions avec les données chargées dans notre variable data.\n",
    "description": "",
    "tags": null,
    "title": "Numpy",
    "uri": "/cours/numpy/index.html"
  },
  {
    "content": " Projet - Fil rouge Le projet fil rouge est l’activité permettant d’évaluer l’atteinte de l’objectif intégrateur du cours. Il se déroulera sur les 5 dernières semaines de la session. Au cours des 4 premières semaines du projet, nous développerons un programme permettant d’explorer, analyser et visualiser des données scientifiques.\nLors de la 5e semaine du projet (dernier cours de la session), vous serez évalués. Votre programme devra être terminé et fonctionnel avant la dernière séance de cours. Votre programme devra être déposé sur Moodle avant la date limite (voir Moodle pour la date limite pour votre groupe).\nLors de l’évaluation, il vous sera demandé de modifier ou d’ajouter certaines fonctionnalités à votre programme. Le programme remis à la fin de cette évaluation sera évalué. Lors de l’évaluation, vous n’aurez pas accès à des ressources extérieures (Internet ou collègues). Le projet doit être fait individuellement (évaluation et préparation).\nLe projet comporte 4 parties :\nPartie 1 : Extraction des données Partie 2 : Nettoyage des données Partie 3 : Affichage des données Partie 4 : Analyse des données Mise en situation blabla….\nOn trouve un sujet (qui pourra être changé de session en session).\nFichiers Fichier Description projetFilRouge.ipynb Tout le projet devra être fait dans ce fichier. Les différentes parties sont bien identifiées. Ne sautez pas d’étapes. N’oubliez pas d’inscrire vos informations personnelles dans le haut du fichier. donnees.json Le fichier contenant les données pour le projet. ",
    "description": "",
    "tags": null,
    "title": "Projet - Fil Rouge",
    "uri": "/cours/projet-fil-rouge/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
